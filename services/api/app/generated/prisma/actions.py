# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'fullName': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'fullName': 'bbehjachib',
                },
                {
                    # data to create a User record
                    'fullName': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 368800899,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 1508029952,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 486256185,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the role field
        users = await User.prisma().find_many(
            take=5,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the country field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'country': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the createdAt field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 1062517886,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 267834847,
            },
            data={
                'create': {
                    'id': 267834847,
                    'fullName': 'cadfabfehe',
                },
                'update': {
                    'fullName': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'acceptedTerms': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'bio': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by city values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['city'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrganizationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Organization]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Organization.prisma().query_raw(
            'SELECT * FROM Organization WHERE id = $1',
            180171308,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Organization
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Organization.prisma().query_first(
            'SELECT * FROM Organization WHERE name = $1',
            'idghgaicb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrganizationCreateInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Organization record.

        Parameters
        ----------
        data
            Organization record data
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The created Organization record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Organization record from just the required fields
        organization = await Organization.prisma().create(
            data={
                # data to create a Organization record
                'name': 'fjfddhigg',
                'slug': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrganizationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Organization records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Organization record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Organization.prisma().create_many(
            data=[
                {
                    # data to create a Organization record
                    'name': 'cbbbjbfcii',
                    'slug': 'bbejhfidcb',
                },
                {
                    # data to create a Organization record
                    'name': 'bgeecijdgg',
                    'slug': 'bdiicjafbj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Organization record.

        Parameters
        ----------
        where
            Organization filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The deleted Organization record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().delete(
            where={
                'id': 1647418052,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Organization record.

        Parameters
        ----------
        where
            Organization filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The found Organization record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().find_unique(
            where={
                'id': 1675546029,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Organization record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Organization filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The found Organization record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().find_unique_or_raise(
            where={
                'id': 1767274722,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Organization records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Organization records returned
        skip
            Ignore the first N results
        where
            Organization filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Organization]
            The list of all Organization records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Organization records
        organizations = await Organization.prisma().find_many(take=10)

        # find the first 5 Organization records ordered by the slug field
        organizations = await Organization.prisma().find_many(
            take=5,
            order={
                'slug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Organization record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Organization filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Organization
            The first Organization record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Organization record ordered by the description field
        organization = await Organization.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Organization record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Organization filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Organization
            The first Organization record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Organization record ordered by the country field
        organization = await Organization.prisma().find_first_or_raise(
            skip=1,
            order={
                'country': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrganizationUpdateInput,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Organization record.

        Parameters
        ----------
        data
            Organization record data specifying what to update
        where
            Organization filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The updated Organization record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        organization = await Organization.prisma().update(
            where={
                'id': 326272115,
            },
            data={
                # data to update the Organization record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrganizationWhereUniqueInput,
        data: types.OrganizationUpsertInput,
        include: Optional[types.OrganizationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Organization filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The created or updated Organization record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().upsert(
            where={
                'id': 1343201072,
            },
            data={
                'create': {
                    'id': 1343201072,
                    'name': 'bgeecijdgg',
                    'slug': 'bdiicjafbj',
                },
                'update': {
                    'name': 'bgeecijdgg',
                    'slug': 'bdiicjafbj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrganizationUpdateManyMutationInput,
        where: types.OrganizationWhereInput,
    ) -> int:
        """Update multiple Organization records

        Parameters
        ----------
        data
            Organization data to update the selected Organization records to
        where
            Filter to select the Organization records to update

        Returns
        -------
        int
            The total number of Organization records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Organization records
        total = await Organization.prisma().update_many(
            data={
                'website': 'ghfhiafcb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Organization records present in the database

        Parameters
        ----------
        select
            Select the Organization fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Organization filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Organization.prisma().count()

        # results: prisma.types.OrganizationCountAggregateOutput
        results = await Organization.prisma().count(
            select={
                '_all': True,
                'industry': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrganizationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> types.OrganizationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrganizationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> Union[int, types.OrganizationCountAggregateOutput]:
        """Count the number of Organization records present in the database

        Parameters
        ----------
        select
            Select the Organization fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Organization filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Organization.prisma().count()

        # results: prisma.types.OrganizationCountAggregateOutput
        results = await Organization.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrganizationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrganizationWhereInput] = None
    ) -> int:
        """Delete multiple Organization records.

        Parameters
        ----------
        where
            Optional Organization filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Organization records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Organization records
        total = await Organization.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrganizationScalarFieldKeys'],
        *,
        where: Optional['types.OrganizationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrganizationAvgAggregateInput'] = None,
        sum: Optional['types.OrganizationSumAggregateInput'] = None,
        min: Optional['types.OrganizationMinAggregateInput'] = None,
        max: Optional['types.OrganizationMaxAggregateInput'] = None,
        having: Optional['types.OrganizationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrganizationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrganizationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrganizationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrganizationGroupByOutput']:
        """Group Organization records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Organization fields to group records by
        where
            Organization filter to select records
        take
            Limit the maximum number of Organization records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrganizationGroupByOutput]
            A list of dictionaries representing the Organization record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Organization records by updatedAt values
        # and count how many records are in each group
        results = await Organization.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrganizationMemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.OrganizationMember]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await OrganizationMember.prisma().query_raw(
            'SELECT * FROM OrganizationMember WHERE id = $1',
            744964398,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.OrganizationMember
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await OrganizationMember.prisma().query_first(
            'SELECT * FROM OrganizationMember WHERE organizationId = $1',
            1969681615,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrganizationMemberCreateInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new OrganizationMember record.

        Parameters
        ----------
        data
            OrganizationMember record data
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The created OrganizationMember record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a OrganizationMember record from just the required fields
        organizationmember = await OrganizationMember.prisma().create(
            data={
                # data to create a OrganizationMember record
                'organizationId': 1116175964,
                'userId': 861472101,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrganizationMemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple OrganizationMember records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of OrganizationMember record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await OrganizationMember.prisma().create_many(
            data=[
                {
                    # data to create a OrganizationMember record
                    'organizationId': 1303003706,
                    'userId': 1686638315,
                },
                {
                    # data to create a OrganizationMember record
                    'organizationId': 2000430152,
                    'userId': 1868141281,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrganizationMemberWhereUniqueInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single OrganizationMember record.

        Parameters
        ----------
        where
            OrganizationMember filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The deleted OrganizationMember record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().delete(
            where={
                'id': 1860847622,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrganizationMemberWhereUniqueInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique OrganizationMember record.

        Parameters
        ----------
        where
            OrganizationMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The found OrganizationMember record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().find_unique(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrganizationMemberWhereUniqueInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique OrganizationMember record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            OrganizationMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The found OrganizationMember record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().find_unique_or_raise(
            where={
                'id': 1628650740,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
        include: Optional[types.OrganizationMemberInclude] = None,
        order: Optional[Union[types.OrganizationMemberOrderByInput, List[types.OrganizationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationMemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple OrganizationMember records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of OrganizationMember records returned
        skip
            Ignore the first N results
        where
            OrganizationMember filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationMember model
        order
            Order the returned OrganizationMember records by any field
        distinct
            Filter OrganizationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.OrganizationMember]
            The list of all OrganizationMember records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 OrganizationMember records
        organizationmembers = await OrganizationMember.prisma().find_many(take=10)

        # find the first 5 OrganizationMember records ordered by the userId field
        organizationmembers = await OrganizationMember.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
        include: Optional[types.OrganizationMemberInclude] = None,
        order: Optional[Union[types.OrganizationMemberOrderByInput, List[types.OrganizationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationMemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single OrganizationMember record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrganizationMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationMember model
        order
            Order the returned OrganizationMember records by any field
        distinct
            Filter OrganizationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrganizationMember
            The first OrganizationMember record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrganizationMember record ordered by the role field
        organizationmember = await OrganizationMember.prisma().find_first(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
        include: Optional[types.OrganizationMemberInclude] = None,
        order: Optional[Union[types.OrganizationMemberOrderByInput, List[types.OrganizationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationMemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single OrganizationMember record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrganizationMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationMember model
        order
            Order the returned OrganizationMember records by any field
        distinct
            Filter OrganizationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrganizationMember
            The first OrganizationMember record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrganizationMember record ordered by the invitedById field
        organizationmember = await OrganizationMember.prisma().find_first_or_raise(
            skip=1,
            order={
                'invitedById': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrganizationMemberUpdateInput,
        where: types.OrganizationMemberWhereUniqueInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single OrganizationMember record.

        Parameters
        ----------
        data
            OrganizationMember record data specifying what to update
        where
            OrganizationMember filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The updated OrganizationMember record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().update(
            where={
                'id': 1249606685,
            },
            data={
                # data to update the OrganizationMember record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrganizationMemberWhereUniqueInput,
        data: types.OrganizationMemberUpsertInput,
        include: Optional[types.OrganizationMemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            OrganizationMember filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The created or updated OrganizationMember record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().upsert(
            where={
                'id': 835903122,
            },
            data={
                'create': {
                    'id': 835903122,
                    'organizationId': 2000430152,
                    'userId': 1868141281,
                },
                'update': {
                    'organizationId': 2000430152,
                    'userId': 1868141281,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrganizationMemberUpdateManyMutationInput,
        where: types.OrganizationMemberWhereInput,
    ) -> int:
        """Update multiple OrganizationMember records

        Parameters
        ----------
        data
            OrganizationMember data to update the selected OrganizationMember records to
        where
            Filter to select the OrganizationMember records to update

        Returns
        -------
        int
            The total number of OrganizationMember records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all OrganizationMember records
        total = await OrganizationMember.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of OrganizationMember records present in the database

        Parameters
        ----------
        select
            Select the OrganizationMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrganizationMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrganizationMember.prisma().count()

        # results: prisma.types.OrganizationMemberCountAggregateOutput
        results = await OrganizationMember.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrganizationMemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
    ) -> types.OrganizationMemberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrganizationMemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
    ) -> Union[int, types.OrganizationMemberCountAggregateOutput]:
        """Count the number of OrganizationMember records present in the database

        Parameters
        ----------
        select
            Select the OrganizationMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrganizationMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrganizationMember.prisma().count()

        # results: prisma.types.OrganizationMemberCountAggregateOutput
        results = await OrganizationMember.prisma().count(
            select={
                '_all': True,
                'deletedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrganizationMemberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrganizationMemberWhereInput] = None
    ) -> int:
        """Delete multiple OrganizationMember records.

        Parameters
        ----------
        where
            Optional OrganizationMember filter to find the records to be deleted

        Returns
        -------
        int
            The total number of OrganizationMember records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all OrganizationMember records
        total = await OrganizationMember.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrganizationMemberScalarFieldKeys'],
        *,
        where: Optional['types.OrganizationMemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrganizationMemberAvgAggregateInput'] = None,
        sum: Optional['types.OrganizationMemberSumAggregateInput'] = None,
        min: Optional['types.OrganizationMemberMinAggregateInput'] = None,
        max: Optional['types.OrganizationMemberMaxAggregateInput'] = None,
        having: Optional['types.OrganizationMemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrganizationMemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrganizationMemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrganizationMemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrganizationMemberGroupByOutput']:
        """Group OrganizationMember records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar OrganizationMember fields to group records by
        where
            OrganizationMember filter to select records
        take
            Limit the maximum number of OrganizationMember records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrganizationMemberGroupByOutput]
            A list of dictionaries representing the OrganizationMember record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group OrganizationMember records by id values
        # and count how many records are in each group
        results = await OrganizationMember.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PathActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Path]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Path.prisma().query_raw(
            'SELECT * FROM Path WHERE id = $1',
            763719779,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Path
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Path.prisma().query_first(
            'SELECT * FROM Path WHERE title = $1',
            'ecjjjfbae',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PathCreateInput,
        include: Optional[types.PathInclude] = None
    ) -> _PrismaModelT:
        """Create a new Path record.

        Parameters
        ----------
        data
            Path record data
        include
            Specifies which relations should be loaded on the returned Path model

        Returns
        -------
        prisma.models.Path
            The created Path record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Path record from just the required fields
        path = await Path.prisma().create(
            data={
                # data to create a Path record
                'title': 'bhhfibbigf',
                'slug': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PathCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Path records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Path record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Path.prisma().create_many(
            data=[
                {
                    # data to create a Path record
                    'title': 'jjfeafhfj',
                    'slug': 'cbachdgfce',
                },
                {
                    # data to create a Path record
                    'title': 'chbfcacbd',
                    'slug': 'efggddide',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PathWhereUniqueInput,
        include: Optional[types.PathInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Path record.

        Parameters
        ----------
        where
            Path filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Path model

        Returns
        -------
        prisma.models.Path
            The deleted Path record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        path = await Path.prisma().delete(
            where={
                'id': 2058258651,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PathWhereUniqueInput,
        include: Optional[types.PathInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Path record.

        Parameters
        ----------
        where
            Path filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Path model

        Returns
        -------
        prisma.models.Path
            The found Path record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        path = await Path.prisma().find_unique(
            where={
                'id': 1583689592,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PathWhereUniqueInput,
        include: Optional[types.PathInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Path record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Path filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Path model

        Returns
        -------
        prisma.models.Path
            The found Path record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        path = await Path.prisma().find_unique_or_raise(
            where={
                'id': 878442065,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PathWhereInput] = None,
        cursor: Optional[types.PathWhereUniqueInput] = None,
        include: Optional[types.PathInclude] = None,
        order: Optional[Union[types.PathOrderByInput, List[types.PathOrderByInput]]] = None,
        distinct: Optional[List[types.PathScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Path records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Path records returned
        skip
            Ignore the first N results
        where
            Path filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Path model
        order
            Order the returned Path records by any field
        distinct
            Filter Path records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Path]
            The list of all Path records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Path records
        paths = await Path.prisma().find_many(take=10)

        # find the first 5 Path records ordered by the slug field
        paths = await Path.prisma().find_many(
            take=5,
            order={
                'slug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PathWhereInput] = None,
        cursor: Optional[types.PathWhereUniqueInput] = None,
        include: Optional[types.PathInclude] = None,
        order: Optional[Union[types.PathOrderByInput, List[types.PathOrderByInput]]] = None,
        distinct: Optional[List[types.PathScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Path record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Path filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Path model
        order
            Order the returned Path records by any field
        distinct
            Filter Path records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Path
            The first Path record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Path record ordered by the description field
        path = await Path.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PathWhereInput] = None,
        cursor: Optional[types.PathWhereUniqueInput] = None,
        include: Optional[types.PathInclude] = None,
        order: Optional[Union[types.PathOrderByInput, List[types.PathOrderByInput]]] = None,
        distinct: Optional[List[types.PathScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Path record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Path filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Path model
        order
            Order the returned Path records by any field
        distinct
            Filter Path records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Path
            The first Path record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Path record ordered by the createdAt field
        path = await Path.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PathUpdateInput,
        where: types.PathWhereUniqueInput,
        include: Optional[types.PathInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Path record.

        Parameters
        ----------
        data
            Path record data specifying what to update
        where
            Path filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Path model

        Returns
        -------
        prisma.models.Path
            The updated Path record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        path = await Path.prisma().update(
            where={
                'id': 1675280054,
            },
            data={
                # data to update the Path record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PathWhereUniqueInput,
        data: types.PathUpsertInput,
        include: Optional[types.PathInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Path filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Path model

        Returns
        -------
        prisma.models.Path
            The created or updated Path record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        path = await Path.prisma().upsert(
            where={
                'id': 1627576247,
            },
            data={
                'create': {
                    'id': 1627576247,
                    'title': 'chbfcacbd',
                    'slug': 'efggddide',
                },
                'update': {
                    'title': 'chbfcacbd',
                    'slug': 'efggddide',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PathUpdateManyMutationInput,
        where: types.PathWhereInput,
    ) -> int:
        """Update multiple Path records

        Parameters
        ----------
        data
            Path data to update the selected Path records to
        where
            Filter to select the Path records to update

        Returns
        -------
        int
            The total number of Path records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Path records
        total = await Path.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PathWhereInput] = None,
        cursor: Optional[types.PathWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Path records present in the database

        Parameters
        ----------
        select
            Select the Path fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Path filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PathCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Path.prisma().count()

        # results: prisma.types.PathCountAggregateOutput
        results = await Path.prisma().count(
            select={
                '_all': True,
                'deletedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PathCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PathWhereInput] = None,
        cursor: Optional[types.PathWhereUniqueInput] = None,
    ) -> types.PathCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PathCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PathWhereInput] = None,
        cursor: Optional[types.PathWhereUniqueInput] = None,
    ) -> Union[int, types.PathCountAggregateOutput]:
        """Count the number of Path records present in the database

        Parameters
        ----------
        select
            Select the Path fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Path filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PathCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Path.prisma().count()

        # results: prisma.types.PathCountAggregateOutput
        results = await Path.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PathCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PathWhereInput] = None
    ) -> int:
        """Delete multiple Path records.

        Parameters
        ----------
        where
            Optional Path filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Path records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Path records
        total = await Path.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PathScalarFieldKeys'],
        *,
        where: Optional['types.PathWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PathAvgAggregateInput'] = None,
        sum: Optional['types.PathSumAggregateInput'] = None,
        min: Optional['types.PathMinAggregateInput'] = None,
        max: Optional['types.PathMaxAggregateInput'] = None,
        having: Optional['types.PathScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PathCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PathScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PathScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PathGroupByOutput']:
        """Group Path records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Path fields to group records by
        where
            Path filter to select records
        take
            Limit the maximum number of Path records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PathGroupByOutput]
            A list of dictionaries representing the Path record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Path records by title values
        # and count how many records are in each group
        results = await Path.prisma().group_by(
            ['title'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ModuleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Module]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Module.prisma().query_raw(
            'SELECT * FROM Module WHERE id = $1',
            2054802212,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Module
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Module.prisma().query_first(
            'SELECT * FROM Module WHERE title = $1',
            'gaddfhfh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ModuleCreateInput,
        include: Optional[types.ModuleInclude] = None
    ) -> _PrismaModelT:
        """Create a new Module record.

        Parameters
        ----------
        data
            Module record data
        include
            Specifies which relations should be loaded on the returned Module model

        Returns
        -------
        prisma.models.Module
            The created Module record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Module record from just the required fields
        module = await Module.prisma().create(
            data={
                # data to create a Module record
                'title': 'gieegcbeg',
                'slug': 'bgcffadich',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ModuleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Module records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Module record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Module.prisma().create_many(
            data=[
                {
                    # data to create a Module record
                    'title': 'fcbichhci',
                    'slug': 'bcggadccgf',
                },
                {
                    # data to create a Module record
                    'title': 'jdcfdcgc',
                    'slug': 'cafdaehjid',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ModuleWhereUniqueInput,
        include: Optional[types.ModuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Module record.

        Parameters
        ----------
        where
            Module filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Module model

        Returns
        -------
        prisma.models.Module
            The deleted Module record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        module = await Module.prisma().delete(
            where={
                'id': 685333180,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ModuleWhereUniqueInput,
        include: Optional[types.ModuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Module record.

        Parameters
        ----------
        where
            Module filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Module model

        Returns
        -------
        prisma.models.Module
            The found Module record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        module = await Module.prisma().find_unique(
            where={
                'id': 127474245,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ModuleWhereUniqueInput,
        include: Optional[types.ModuleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Module record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Module filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Module model

        Returns
        -------
        prisma.models.Module
            The found Module record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        module = await Module.prisma().find_unique_or_raise(
            where={
                'id': 948921754,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ModuleWhereInput] = None,
        cursor: Optional[types.ModuleWhereUniqueInput] = None,
        include: Optional[types.ModuleInclude] = None,
        order: Optional[Union[types.ModuleOrderByInput, List[types.ModuleOrderByInput]]] = None,
        distinct: Optional[List[types.ModuleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Module records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Module records returned
        skip
            Ignore the first N results
        where
            Module filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Module model
        order
            Order the returned Module records by any field
        distinct
            Filter Module records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Module]
            The list of all Module records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Module records
        modules = await Module.prisma().find_many(take=10)

        # find the first 5 Module records ordered by the slug field
        modules = await Module.prisma().find_many(
            take=5,
            order={
                'slug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ModuleWhereInput] = None,
        cursor: Optional[types.ModuleWhereUniqueInput] = None,
        include: Optional[types.ModuleInclude] = None,
        order: Optional[Union[types.ModuleOrderByInput, List[types.ModuleOrderByInput]]] = None,
        distinct: Optional[List[types.ModuleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Module record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Module filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Module model
        order
            Order the returned Module records by any field
        distinct
            Filter Module records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Module
            The first Module record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Module record ordered by the description field
        module = await Module.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ModuleWhereInput] = None,
        cursor: Optional[types.ModuleWhereUniqueInput] = None,
        include: Optional[types.ModuleInclude] = None,
        order: Optional[Union[types.ModuleOrderByInput, List[types.ModuleOrderByInput]]] = None,
        distinct: Optional[List[types.ModuleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Module record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Module filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Module model
        order
            Order the returned Module records by any field
        distinct
            Filter Module records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Module
            The first Module record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Module record ordered by the fullDescription field
        module = await Module.prisma().find_first_or_raise(
            skip=1,
            order={
                'fullDescription': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ModuleUpdateInput,
        where: types.ModuleWhereUniqueInput,
        include: Optional[types.ModuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Module record.

        Parameters
        ----------
        data
            Module record data specifying what to update
        where
            Module filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Module model

        Returns
        -------
        prisma.models.Module
            The updated Module record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        module = await Module.prisma().update(
            where={
                'id': 1964990155,
            },
            data={
                # data to update the Module record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ModuleWhereUniqueInput,
        data: types.ModuleUpsertInput,
        include: Optional[types.ModuleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Module filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Module model

        Returns
        -------
        prisma.models.Module
            The created or updated Module record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        module = await Module.prisma().upsert(
            where={
                'id': 1228891816,
            },
            data={
                'create': {
                    'id': 1228891816,
                    'title': 'jdcfdcgc',
                    'slug': 'cafdaehjid',
                },
                'update': {
                    'title': 'jdcfdcgc',
                    'slug': 'cafdaehjid',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ModuleUpdateManyMutationInput,
        where: types.ModuleWhereInput,
    ) -> int:
        """Update multiple Module records

        Parameters
        ----------
        data
            Module data to update the selected Module records to
        where
            Filter to select the Module records to update

        Returns
        -------
        int
            The total number of Module records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Module records
        total = await Module.prisma().update_many(
            data={
                'durationMinutes': 255202753
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ModuleWhereInput] = None,
        cursor: Optional[types.ModuleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Module records present in the database

        Parameters
        ----------
        select
            Select the Module fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Module filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ModuleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Module.prisma().count()

        # results: prisma.types.ModuleCountAggregateOutput
        results = await Module.prisma().count(
            select={
                '_all': True,
                'estimatedEffort': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ModuleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ModuleWhereInput] = None,
        cursor: Optional[types.ModuleWhereUniqueInput] = None,
    ) -> types.ModuleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ModuleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ModuleWhereInput] = None,
        cursor: Optional[types.ModuleWhereUniqueInput] = None,
    ) -> Union[int, types.ModuleCountAggregateOutput]:
        """Count the number of Module records present in the database

        Parameters
        ----------
        select
            Select the Module fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Module filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ModuleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Module.prisma().count()

        # results: prisma.types.ModuleCountAggregateOutput
        results = await Module.prisma().count(
            select={
                '_all': True,
                'totalLessons': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ModuleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ModuleWhereInput] = None
    ) -> int:
        """Delete multiple Module records.

        Parameters
        ----------
        where
            Optional Module filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Module records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Module records
        total = await Module.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ModuleScalarFieldKeys'],
        *,
        where: Optional['types.ModuleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ModuleAvgAggregateInput'] = None,
        sum: Optional['types.ModuleSumAggregateInput'] = None,
        min: Optional['types.ModuleMinAggregateInput'] = None,
        max: Optional['types.ModuleMaxAggregateInput'] = None,
        having: Optional['types.ModuleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ModuleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ModuleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ModuleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ModuleGroupByOutput']:
        """Group Module records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Module fields to group records by
        where
            Module filter to select records
        take
            Limit the maximum number of Module records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ModuleGroupByOutput]
            A list of dictionaries representing the Module record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Module records by level values
        # and count how many records are in each group
        results = await Module.prisma().group_by(
            ['level'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PathModuleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PathModule]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PathModule.prisma().query_raw(
            'SELECT * FROM PathModule WHERE id = $1',
            1223573862,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PathModule
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PathModule.prisma().query_first(
            'SELECT * FROM PathModule WHERE pathId = $1',
            541269159,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PathModuleCreateInput,
        include: Optional[types.PathModuleInclude] = None
    ) -> _PrismaModelT:
        """Create a new PathModule record.

        Parameters
        ----------
        data
            PathModule record data
        include
            Specifies which relations should be loaded on the returned PathModule model

        Returns
        -------
        prisma.models.PathModule
            The created PathModule record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PathModule record from just the required fields
        pathmodule = await PathModule.prisma().create(
            data={
                # data to create a PathModule record
                'pathId': 1064846676,
                'moduleId': 508382461,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PathModuleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PathModule records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PathModule record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PathModule.prisma().create_many(
            data=[
                {
                    # data to create a PathModule record
                    'pathId': 1024265714,
                    'moduleId': 872078403,
                },
                {
                    # data to create a PathModule record
                    'pathId': 1874748096,
                    'moduleId': 916896761,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PathModuleWhereUniqueInput,
        include: Optional[types.PathModuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PathModule record.

        Parameters
        ----------
        where
            PathModule filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PathModule model

        Returns
        -------
        prisma.models.PathModule
            The deleted PathModule record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pathmodule = await PathModule.prisma().delete(
            where={
                'id': 769267518,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PathModuleWhereUniqueInput,
        include: Optional[types.PathModuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PathModule record.

        Parameters
        ----------
        where
            PathModule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PathModule model

        Returns
        -------
        prisma.models.PathModule
            The found PathModule record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pathmodule = await PathModule.prisma().find_unique(
            where={
                'id': 820312479,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PathModuleWhereUniqueInput,
        include: Optional[types.PathModuleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PathModule record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PathModule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PathModule model

        Returns
        -------
        prisma.models.PathModule
            The found PathModule record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pathmodule = await PathModule.prisma().find_unique_or_raise(
            where={
                'id': 92728044,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PathModuleWhereInput] = None,
        cursor: Optional[types.PathModuleWhereUniqueInput] = None,
        include: Optional[types.PathModuleInclude] = None,
        order: Optional[Union[types.PathModuleOrderByInput, List[types.PathModuleOrderByInput]]] = None,
        distinct: Optional[List[types.PathModuleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PathModule records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PathModule records returned
        skip
            Ignore the first N results
        where
            PathModule filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PathModule model
        order
            Order the returned PathModule records by any field
        distinct
            Filter PathModule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PathModule]
            The list of all PathModule records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PathModule records
        pathmodules = await PathModule.prisma().find_many(take=10)

        # find the first 5 PathModule records ordered by the moduleId field
        pathmodules = await PathModule.prisma().find_many(
            take=5,
            order={
                'moduleId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PathModuleWhereInput] = None,
        cursor: Optional[types.PathModuleWhereUniqueInput] = None,
        include: Optional[types.PathModuleInclude] = None,
        order: Optional[Union[types.PathModuleOrderByInput, List[types.PathModuleOrderByInput]]] = None,
        distinct: Optional[List[types.PathModuleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PathModule record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PathModule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PathModule model
        order
            Order the returned PathModule records by any field
        distinct
            Filter PathModule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PathModule
            The first PathModule record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PathModule record ordered by the order field
        pathmodule = await PathModule.prisma().find_first(
            skip=1,
            order={
                'order': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PathModuleWhereInput] = None,
        cursor: Optional[types.PathModuleWhereUniqueInput] = None,
        include: Optional[types.PathModuleInclude] = None,
        order: Optional[Union[types.PathModuleOrderByInput, List[types.PathModuleOrderByInput]]] = None,
        distinct: Optional[List[types.PathModuleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PathModule record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PathModule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PathModule model
        order
            Order the returned PathModule records by any field
        distinct
            Filter PathModule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PathModule
            The first PathModule record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PathModule record ordered by the id field
        pathmodule = await PathModule.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PathModuleUpdateInput,
        where: types.PathModuleWhereUniqueInput,
        include: Optional[types.PathModuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PathModule record.

        Parameters
        ----------
        data
            PathModule record data specifying what to update
        where
            PathModule filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PathModule model

        Returns
        -------
        prisma.models.PathModule
            The updated PathModule record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        pathmodule = await PathModule.prisma().update(
            where={
                'id': 344858293,
            },
            data={
                # data to update the PathModule record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PathModuleWhereUniqueInput,
        data: types.PathModuleUpsertInput,
        include: Optional[types.PathModuleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PathModule filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PathModule model

        Returns
        -------
        prisma.models.PathModule
            The created or updated PathModule record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pathmodule = await PathModule.prisma().upsert(
            where={
                'id': 1121741130,
            },
            data={
                'create': {
                    'id': 1121741130,
                    'pathId': 1874748096,
                    'moduleId': 916896761,
                },
                'update': {
                    'pathId': 1874748096,
                    'moduleId': 916896761,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PathModuleUpdateManyMutationInput,
        where: types.PathModuleWhereInput,
    ) -> int:
        """Update multiple PathModule records

        Parameters
        ----------
        data
            PathModule data to update the selected PathModule records to
        where
            Filter to select the PathModule records to update

        Returns
        -------
        int
            The total number of PathModule records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PathModule records
        total = await PathModule.prisma().update_many(
            data={
                'pathId': 1495896251
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PathModuleWhereInput] = None,
        cursor: Optional[types.PathModuleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PathModule records present in the database

        Parameters
        ----------
        select
            Select the PathModule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PathModule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PathModuleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PathModule.prisma().count()

        # results: prisma.types.PathModuleCountAggregateOutput
        results = await PathModule.prisma().count(
            select={
                '_all': True,
                'moduleId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PathModuleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PathModuleWhereInput] = None,
        cursor: Optional[types.PathModuleWhereUniqueInput] = None,
    ) -> types.PathModuleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PathModuleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PathModuleWhereInput] = None,
        cursor: Optional[types.PathModuleWhereUniqueInput] = None,
    ) -> Union[int, types.PathModuleCountAggregateOutput]:
        """Count the number of PathModule records present in the database

        Parameters
        ----------
        select
            Select the PathModule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PathModule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PathModuleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PathModule.prisma().count()

        # results: prisma.types.PathModuleCountAggregateOutput
        results = await PathModule.prisma().count(
            select={
                '_all': True,
                'order': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PathModuleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PathModuleWhereInput] = None
    ) -> int:
        """Delete multiple PathModule records.

        Parameters
        ----------
        where
            Optional PathModule filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PathModule records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PathModule records
        total = await PathModule.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PathModuleScalarFieldKeys'],
        *,
        where: Optional['types.PathModuleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PathModuleAvgAggregateInput'] = None,
        sum: Optional['types.PathModuleSumAggregateInput'] = None,
        min: Optional['types.PathModuleMinAggregateInput'] = None,
        max: Optional['types.PathModuleMaxAggregateInput'] = None,
        having: Optional['types.PathModuleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PathModuleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PathModuleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PathModuleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PathModuleGroupByOutput']:
        """Group PathModule records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PathModule fields to group records by
        where
            PathModule filter to select records
        take
            Limit the maximum number of PathModule records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PathModuleGroupByOutput]
            A list of dictionaries representing the PathModule record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PathModule records by id values
        # and count how many records are in each group
        results = await PathModule.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LessonActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Lesson]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Lesson.prisma().query_raw(
            'SELECT * FROM Lesson WHERE id = $1',
            208521688,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Lesson
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Lesson.prisma().query_first(
            'SELECT * FROM Lesson WHERE moduleId = $1',
            860811569,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LessonCreateInput,
        include: Optional[types.LessonInclude] = None
    ) -> _PrismaModelT:
        """Create a new Lesson record.

        Parameters
        ----------
        data
            Lesson record data
        include
            Specifies which relations should be loaded on the returned Lesson model

        Returns
        -------
        prisma.models.Lesson
            The created Lesson record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Lesson record from just the required fields
        lesson = await Lesson.prisma().create(
            data={
                # data to create a Lesson record
                'moduleId': 1660932118,
                'title': 'fcfhgbjed',
                'type': 'hdgcajhjg',
                'order': 493907821,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LessonCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Lesson records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Lesson record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Lesson.prisma().create_many(
            data=[
                {
                    # data to create a Lesson record
                    'moduleId': 639686562,
                    'title': 'gfeaahdeh',
                    'type': 'bjafcgbffc',
                    'order': 78746985,
                },
                {
                    # data to create a Lesson record
                    'moduleId': 1398328302,
                    'title': 'ifgaaagff',
                    'type': 'befcddgjce',
                    'order': 1573199653,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LessonWhereUniqueInput,
        include: Optional[types.LessonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Lesson record.

        Parameters
        ----------
        where
            Lesson filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Lesson model

        Returns
        -------
        prisma.models.Lesson
            The deleted Lesson record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lesson = await Lesson.prisma().delete(
            where={
                'id': 2013903098,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LessonWhereUniqueInput,
        include: Optional[types.LessonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Lesson record.

        Parameters
        ----------
        where
            Lesson filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Lesson model

        Returns
        -------
        prisma.models.Lesson
            The found Lesson record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lesson = await Lesson.prisma().find_unique(
            where={
                'id': 500965035,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LessonWhereUniqueInput,
        include: Optional[types.LessonInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Lesson record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Lesson filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Lesson model

        Returns
        -------
        prisma.models.Lesson
            The found Lesson record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lesson = await Lesson.prisma().find_unique_or_raise(
            where={
                'id': 1800624392,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LessonWhereInput] = None,
        cursor: Optional[types.LessonWhereUniqueInput] = None,
        include: Optional[types.LessonInclude] = None,
        order: Optional[Union[types.LessonOrderByInput, List[types.LessonOrderByInput]]] = None,
        distinct: Optional[List[types.LessonScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Lesson records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Lesson records returned
        skip
            Ignore the first N results
        where
            Lesson filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lesson model
        order
            Order the returned Lesson records by any field
        distinct
            Filter Lesson records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Lesson]
            The list of all Lesson records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Lesson records
        lessons = await Lesson.prisma().find_many(take=10)

        # find the first 5 Lesson records ordered by the title field
        lessons = await Lesson.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LessonWhereInput] = None,
        cursor: Optional[types.LessonWhereUniqueInput] = None,
        include: Optional[types.LessonInclude] = None,
        order: Optional[Union[types.LessonOrderByInput, List[types.LessonOrderByInput]]] = None,
        distinct: Optional[List[types.LessonScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Lesson record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Lesson filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lesson model
        order
            Order the returned Lesson records by any field
        distinct
            Filter Lesson records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Lesson
            The first Lesson record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Lesson record ordered by the description field
        lesson = await Lesson.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LessonWhereInput] = None,
        cursor: Optional[types.LessonWhereUniqueInput] = None,
        include: Optional[types.LessonInclude] = None,
        order: Optional[Union[types.LessonOrderByInput, List[types.LessonOrderByInput]]] = None,
        distinct: Optional[List[types.LessonScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Lesson record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Lesson filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lesson model
        order
            Order the returned Lesson records by any field
        distinct
            Filter Lesson records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Lesson
            The first Lesson record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Lesson record ordered by the durationMinutes field
        lesson = await Lesson.prisma().find_first_or_raise(
            skip=1,
            order={
                'durationMinutes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LessonUpdateInput,
        where: types.LessonWhereUniqueInput,
        include: Optional[types.LessonInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Lesson record.

        Parameters
        ----------
        data
            Lesson record data specifying what to update
        where
            Lesson filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Lesson model

        Returns
        -------
        prisma.models.Lesson
            The updated Lesson record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lesson = await Lesson.prisma().update(
            where={
                'id': 2077067425,
            },
            data={
                # data to update the Lesson record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LessonWhereUniqueInput,
        data: types.LessonUpsertInput,
        include: Optional[types.LessonInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Lesson filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Lesson model

        Returns
        -------
        prisma.models.Lesson
            The created or updated Lesson record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lesson = await Lesson.prisma().upsert(
            where={
                'id': 1672112838,
            },
            data={
                'create': {
                    'id': 1672112838,
                    'moduleId': 1398328302,
                    'title': 'ifgaaagff',
                    'type': 'befcddgjce',
                    'order': 1573199653,
                },
                'update': {
                    'moduleId': 1398328302,
                    'title': 'ifgaaagff',
                    'type': 'befcddgjce',
                    'order': 1573199653,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LessonUpdateManyMutationInput,
        where: types.LessonWhereInput,
    ) -> int:
        """Update multiple Lesson records

        Parameters
        ----------
        data
            Lesson data to update the selected Lesson records to
        where
            Filter to select the Lesson records to update

        Returns
        -------
        int
            The total number of Lesson records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Lesson records
        total = await Lesson.prisma().update_many(
            data={
                'type': 'jcgghhgdj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LessonWhereInput] = None,
        cursor: Optional[types.LessonWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Lesson records present in the database

        Parameters
        ----------
        select
            Select the Lesson fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Lesson filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LessonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Lesson.prisma().count()

        # results: prisma.types.LessonCountAggregateOutput
        results = await Lesson.prisma().count(
            select={
                '_all': True,
                'videoUrl': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LessonCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LessonWhereInput] = None,
        cursor: Optional[types.LessonWhereUniqueInput] = None,
    ) -> types.LessonCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LessonCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LessonWhereInput] = None,
        cursor: Optional[types.LessonWhereUniqueInput] = None,
    ) -> Union[int, types.LessonCountAggregateOutput]:
        """Count the number of Lesson records present in the database

        Parameters
        ----------
        select
            Select the Lesson fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Lesson filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LessonCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Lesson.prisma().count()

        # results: prisma.types.LessonCountAggregateOutput
        results = await Lesson.prisma().count(
            select={
                '_all': True,
                'transcript': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LessonCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LessonWhereInput] = None
    ) -> int:
        """Delete multiple Lesson records.

        Parameters
        ----------
        where
            Optional Lesson filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Lesson records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Lesson records
        total = await Lesson.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LessonScalarFieldKeys'],
        *,
        where: Optional['types.LessonWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LessonAvgAggregateInput'] = None,
        sum: Optional['types.LessonSumAggregateInput'] = None,
        min: Optional['types.LessonMinAggregateInput'] = None,
        max: Optional['types.LessonMaxAggregateInput'] = None,
        having: Optional['types.LessonScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LessonCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LessonScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LessonScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LessonGroupByOutput']:
        """Group Lesson records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Lesson fields to group records by
        where
            Lesson filter to select records
        take
            Limit the maximum number of Lesson records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LessonGroupByOutput]
            A list of dictionaries representing the Lesson record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Lesson records by attachments values
        # and count how many records are in each group
        results = await Lesson.prisma().group_by(
            ['attachments'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EnrollmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Enrollment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Enrollment.prisma().query_raw(
            'SELECT * FROM Enrollment WHERE id = $1',
            1447624116,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Enrollment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Enrollment.prisma().query_first(
            'SELECT * FROM Enrollment WHERE userId = $1',
            1738083805,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EnrollmentCreateInput,
        include: Optional[types.EnrollmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Enrollment record.

        Parameters
        ----------
        data
            Enrollment record data
        include
            Specifies which relations should be loaded on the returned Enrollment model

        Returns
        -------
        prisma.models.Enrollment
            The created Enrollment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Enrollment record from just the required fields
        enrollment = await Enrollment.prisma().create(
            data={
                # data to create a Enrollment record
                'userId': 340946258,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EnrollmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Enrollment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Enrollment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Enrollment.prisma().create_many(
            data=[
                {
                    # data to create a Enrollment record
                    'userId': 601077795,
                },
                {
                    # data to create a Enrollment record
                    'userId': 290603296,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EnrollmentWhereUniqueInput,
        include: Optional[types.EnrollmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Enrollment record.

        Parameters
        ----------
        where
            Enrollment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Enrollment model

        Returns
        -------
        prisma.models.Enrollment
            The deleted Enrollment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        enrollment = await Enrollment.prisma().delete(
            where={
                'id': 1855826649,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EnrollmentWhereUniqueInput,
        include: Optional[types.EnrollmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Enrollment record.

        Parameters
        ----------
        where
            Enrollment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Enrollment model

        Returns
        -------
        prisma.models.Enrollment
            The found Enrollment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        enrollment = await Enrollment.prisma().find_unique(
            where={
                'id': 1611009182,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EnrollmentWhereUniqueInput,
        include: Optional[types.EnrollmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Enrollment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Enrollment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Enrollment model

        Returns
        -------
        prisma.models.Enrollment
            The found Enrollment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        enrollment = await Enrollment.prisma().find_unique_or_raise(
            where={
                'id': 446673791,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EnrollmentWhereInput] = None,
        cursor: Optional[types.EnrollmentWhereUniqueInput] = None,
        include: Optional[types.EnrollmentInclude] = None,
        order: Optional[Union[types.EnrollmentOrderByInput, List[types.EnrollmentOrderByInput]]] = None,
        distinct: Optional[List[types.EnrollmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Enrollment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Enrollment records returned
        skip
            Ignore the first N results
        where
            Enrollment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Enrollment model
        order
            Order the returned Enrollment records by any field
        distinct
            Filter Enrollment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Enrollment]
            The list of all Enrollment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Enrollment records
        enrollments = await Enrollment.prisma().find_many(take=10)

        # find the first 5 Enrollment records ordered by the progress field
        enrollments = await Enrollment.prisma().find_many(
            take=5,
            order={
                'progress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EnrollmentWhereInput] = None,
        cursor: Optional[types.EnrollmentWhereUniqueInput] = None,
        include: Optional[types.EnrollmentInclude] = None,
        order: Optional[Union[types.EnrollmentOrderByInput, List[types.EnrollmentOrderByInput]]] = None,
        distinct: Optional[List[types.EnrollmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Enrollment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Enrollment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Enrollment model
        order
            Order the returned Enrollment records by any field
        distinct
            Filter Enrollment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Enrollment
            The first Enrollment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Enrollment record ordered by the createdAt field
        enrollment = await Enrollment.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EnrollmentWhereInput] = None,
        cursor: Optional[types.EnrollmentWhereUniqueInput] = None,
        include: Optional[types.EnrollmentInclude] = None,
        order: Optional[Union[types.EnrollmentOrderByInput, List[types.EnrollmentOrderByInput]]] = None,
        distinct: Optional[List[types.EnrollmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Enrollment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Enrollment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Enrollment model
        order
            Order the returned Enrollment records by any field
        distinct
            Filter Enrollment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Enrollment
            The first Enrollment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Enrollment record ordered by the updatedAt field
        enrollment = await Enrollment.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EnrollmentUpdateInput,
        where: types.EnrollmentWhereUniqueInput,
        include: Optional[types.EnrollmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Enrollment record.

        Parameters
        ----------
        data
            Enrollment record data specifying what to update
        where
            Enrollment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Enrollment model

        Returns
        -------
        prisma.models.Enrollment
            The updated Enrollment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        enrollment = await Enrollment.prisma().update(
            where={
                'id': 300568396,
            },
            data={
                # data to update the Enrollment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EnrollmentWhereUniqueInput,
        data: types.EnrollmentUpsertInput,
        include: Optional[types.EnrollmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Enrollment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Enrollment model

        Returns
        -------
        prisma.models.Enrollment
            The created or updated Enrollment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        enrollment = await Enrollment.prisma().upsert(
            where={
                'id': 632626069,
            },
            data={
                'create': {
                    'id': 632626069,
                    'userId': 290603296,
                },
                'update': {
                    'userId': 290603296,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EnrollmentUpdateManyMutationInput,
        where: types.EnrollmentWhereInput,
    ) -> int:
        """Update multiple Enrollment records

        Parameters
        ----------
        data
            Enrollment data to update the selected Enrollment records to
        where
            Filter to select the Enrollment records to update

        Returns
        -------
        int
            The total number of Enrollment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Enrollment records
        total = await Enrollment.prisma().update_many(
            data={
                'completedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EnrollmentWhereInput] = None,
        cursor: Optional[types.EnrollmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Enrollment records present in the database

        Parameters
        ----------
        select
            Select the Enrollment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Enrollment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EnrollmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Enrollment.prisma().count()

        # results: prisma.types.EnrollmentCountAggregateOutput
        results = await Enrollment.prisma().count(
            select={
                '_all': True,
                'deletedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EnrollmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EnrollmentWhereInput] = None,
        cursor: Optional[types.EnrollmentWhereUniqueInput] = None,
    ) -> types.EnrollmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EnrollmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EnrollmentWhereInput] = None,
        cursor: Optional[types.EnrollmentWhereUniqueInput] = None,
    ) -> Union[int, types.EnrollmentCountAggregateOutput]:
        """Count the number of Enrollment records present in the database

        Parameters
        ----------
        select
            Select the Enrollment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Enrollment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EnrollmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Enrollment.prisma().count()

        # results: prisma.types.EnrollmentCountAggregateOutput
        results = await Enrollment.prisma().count(
            select={
                '_all': True,
                'moduleId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EnrollmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EnrollmentWhereInput] = None
    ) -> int:
        """Delete multiple Enrollment records.

        Parameters
        ----------
        where
            Optional Enrollment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Enrollment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Enrollment records
        total = await Enrollment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EnrollmentScalarFieldKeys'],
        *,
        where: Optional['types.EnrollmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EnrollmentAvgAggregateInput'] = None,
        sum: Optional['types.EnrollmentSumAggregateInput'] = None,
        min: Optional['types.EnrollmentMinAggregateInput'] = None,
        max: Optional['types.EnrollmentMaxAggregateInput'] = None,
        having: Optional['types.EnrollmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EnrollmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EnrollmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EnrollmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EnrollmentGroupByOutput']:
        """Group Enrollment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Enrollment fields to group records by
        where
            Enrollment filter to select records
        take
            Limit the maximum number of Enrollment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EnrollmentGroupByOutput]
            A list of dictionaries representing the Enrollment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Enrollment records by pathId values
        # and count how many records are in each group
        results = await Enrollment.prisma().group_by(
            ['pathId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LessonProgressActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LessonProgress]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LessonProgress.prisma().query_raw(
            'SELECT * FROM LessonProgress WHERE id = $1',
            1724011690,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LessonProgress
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LessonProgress.prisma().query_first(
            'SELECT * FROM LessonProgress WHERE userId = $1',
            470157467,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LessonProgressCreateInput,
        include: Optional[types.LessonProgressInclude] = None
    ) -> _PrismaModelT:
        """Create a new LessonProgress record.

        Parameters
        ----------
        data
            LessonProgress record data
        include
            Specifies which relations should be loaded on the returned LessonProgress model

        Returns
        -------
        prisma.models.LessonProgress
            The created LessonProgress record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LessonProgress record from just the required fields
        lessonprogress = await LessonProgress.prisma().create(
            data={
                # data to create a LessonProgress record
                'userId': 1209209912,
                'lessonId': 1536744465,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LessonProgressCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LessonProgress records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LessonProgress record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LessonProgress.prisma().create_many(
            data=[
                {
                    # data to create a LessonProgress record
                    'userId': 424218998,
                    'lessonId': 2125632375,
                },
                {
                    # data to create a LessonProgress record
                    'userId': 536951780,
                    'lessonId': 924723277,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LessonProgressWhereUniqueInput,
        include: Optional[types.LessonProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LessonProgress record.

        Parameters
        ----------
        where
            LessonProgress filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LessonProgress model

        Returns
        -------
        prisma.models.LessonProgress
            The deleted LessonProgress record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lessonprogress = await LessonProgress.prisma().delete(
            where={
                'id': 1621937922,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LessonProgressWhereUniqueInput,
        include: Optional[types.LessonProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LessonProgress record.

        Parameters
        ----------
        where
            LessonProgress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LessonProgress model

        Returns
        -------
        prisma.models.LessonProgress
            The found LessonProgress record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lessonprogress = await LessonProgress.prisma().find_unique(
            where={
                'id': 1848832019,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LessonProgressWhereUniqueInput,
        include: Optional[types.LessonProgressInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LessonProgress record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LessonProgress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LessonProgress model

        Returns
        -------
        prisma.models.LessonProgress
            The found LessonProgress record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lessonprogress = await LessonProgress.prisma().find_unique_or_raise(
            where={
                'id': 1921528400,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LessonProgressWhereInput] = None,
        cursor: Optional[types.LessonProgressWhereUniqueInput] = None,
        include: Optional[types.LessonProgressInclude] = None,
        order: Optional[Union[types.LessonProgressOrderByInput, List[types.LessonProgressOrderByInput]]] = None,
        distinct: Optional[List[types.LessonProgressScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LessonProgress records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LessonProgress records returned
        skip
            Ignore the first N results
        where
            LessonProgress filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LessonProgress model
        order
            Order the returned LessonProgress records by any field
        distinct
            Filter LessonProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LessonProgress]
            The list of all LessonProgress records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LessonProgress records
        lessonprogress = await LessonProgress.prisma().find_many(take=10)

        # find the first 5 LessonProgress records ordered by the lessonId field
        lessonprogress = await LessonProgress.prisma().find_many(
            take=5,
            order={
                'lessonId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LessonProgressWhereInput] = None,
        cursor: Optional[types.LessonProgressWhereUniqueInput] = None,
        include: Optional[types.LessonProgressInclude] = None,
        order: Optional[Union[types.LessonProgressOrderByInput, List[types.LessonProgressOrderByInput]]] = None,
        distinct: Optional[List[types.LessonProgressScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LessonProgress record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LessonProgress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LessonProgress model
        order
            Order the returned LessonProgress records by any field
        distinct
            Filter LessonProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LessonProgress
            The first LessonProgress record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LessonProgress record ordered by the isCompleted field
        lessonprogress = await LessonProgress.prisma().find_first(
            skip=1,
            order={
                'isCompleted': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LessonProgressWhereInput] = None,
        cursor: Optional[types.LessonProgressWhereUniqueInput] = None,
        include: Optional[types.LessonProgressInclude] = None,
        order: Optional[Union[types.LessonProgressOrderByInput, List[types.LessonProgressOrderByInput]]] = None,
        distinct: Optional[List[types.LessonProgressScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LessonProgress record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LessonProgress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LessonProgress model
        order
            Order the returned LessonProgress records by any field
        distinct
            Filter LessonProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LessonProgress
            The first LessonProgress record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LessonProgress record ordered by the completedAt field
        lessonprogress = await LessonProgress.prisma().find_first_or_raise(
            skip=1,
            order={
                'completedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LessonProgressUpdateInput,
        where: types.LessonProgressWhereUniqueInput,
        include: Optional[types.LessonProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LessonProgress record.

        Parameters
        ----------
        data
            LessonProgress record data specifying what to update
        where
            LessonProgress filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LessonProgress model

        Returns
        -------
        prisma.models.LessonProgress
            The updated LessonProgress record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lessonprogress = await LessonProgress.prisma().update(
            where={
                'id': 2100427849,
            },
            data={
                # data to update the LessonProgress record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LessonProgressWhereUniqueInput,
        data: types.LessonProgressUpsertInput,
        include: Optional[types.LessonProgressInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LessonProgress filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LessonProgress model

        Returns
        -------
        prisma.models.LessonProgress
            The created or updated LessonProgress record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lessonprogress = await LessonProgress.prisma().upsert(
            where={
                'id': 849140046,
            },
            data={
                'create': {
                    'id': 849140046,
                    'userId': 536951780,
                    'lessonId': 924723277,
                },
                'update': {
                    'userId': 536951780,
                    'lessonId': 924723277,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LessonProgressUpdateManyMutationInput,
        where: types.LessonProgressWhereInput,
    ) -> int:
        """Update multiple LessonProgress records

        Parameters
        ----------
        data
            LessonProgress data to update the selected LessonProgress records to
        where
            Filter to select the LessonProgress records to update

        Returns
        -------
        int
            The total number of LessonProgress records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LessonProgress records
        total = await LessonProgress.prisma().update_many(
            data={
                'progress': 928152175.27303
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LessonProgressWhereInput] = None,
        cursor: Optional[types.LessonProgressWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LessonProgress records present in the database

        Parameters
        ----------
        select
            Select the LessonProgress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LessonProgress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LessonProgressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LessonProgress.prisma().count()

        # results: prisma.types.LessonProgressCountAggregateOutput
        results = await LessonProgress.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LessonProgressCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LessonProgressWhereInput] = None,
        cursor: Optional[types.LessonProgressWhereUniqueInput] = None,
    ) -> types.LessonProgressCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LessonProgressCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LessonProgressWhereInput] = None,
        cursor: Optional[types.LessonProgressWhereUniqueInput] = None,
    ) -> Union[int, types.LessonProgressCountAggregateOutput]:
        """Count the number of LessonProgress records present in the database

        Parameters
        ----------
        select
            Select the LessonProgress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LessonProgress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LessonProgressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LessonProgress.prisma().count()

        # results: prisma.types.LessonProgressCountAggregateOutput
        results = await LessonProgress.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LessonProgressCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LessonProgressWhereInput] = None
    ) -> int:
        """Delete multiple LessonProgress records.

        Parameters
        ----------
        where
            Optional LessonProgress filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LessonProgress records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LessonProgress records
        total = await LessonProgress.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LessonProgressScalarFieldKeys'],
        *,
        where: Optional['types.LessonProgressWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LessonProgressAvgAggregateInput'] = None,
        sum: Optional['types.LessonProgressSumAggregateInput'] = None,
        min: Optional['types.LessonProgressMinAggregateInput'] = None,
        max: Optional['types.LessonProgressMaxAggregateInput'] = None,
        having: Optional['types.LessonProgressScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LessonProgressCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LessonProgressScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LessonProgressScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LessonProgressGroupByOutput']:
        """Group LessonProgress records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LessonProgress fields to group records by
        where
            LessonProgress filter to select records
        take
            Limit the maximum number of LessonProgress records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LessonProgressGroupByOutput]
            A list of dictionaries representing the LessonProgress record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LessonProgress records by deletedAt values
        # and count how many records are in each group
        results = await LessonProgress.prisma().group_by(
            ['deletedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CertificateActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Certificate]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Certificate.prisma().query_raw(
            'SELECT * FROM Certificate WHERE id = $1',
            982848517,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Certificate
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Certificate.prisma().query_first(
            'SELECT * FROM Certificate WHERE userId = $1',
            510737498,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CertificateCreateInput,
        include: Optional[types.CertificateInclude] = None
    ) -> _PrismaModelT:
        """Create a new Certificate record.

        Parameters
        ----------
        data
            Certificate record data
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The created Certificate record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Certificate record from just the required fields
        certificate = await Certificate.prisma().create(
            data={
                # data to create a Certificate record
                'userId': 2117488267,
                'fileUrl': 'beabjeejdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CertificateCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Certificate records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Certificate record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Certificate.prisma().create_many(
            data=[
                {
                    # data to create a Certificate record
                    'userId': 1297607553,
                    'fileUrl': 'fbjeiiffa',
                },
                {
                    # data to create a Certificate record
                    'userId': 976832615,
                    'fileUrl': 'bgjgecfejc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CertificateWhereUniqueInput,
        include: Optional[types.CertificateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Certificate record.

        Parameters
        ----------
        where
            Certificate filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The deleted Certificate record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        certificate = await Certificate.prisma().delete(
            where={
                'id': 169262781,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CertificateWhereUniqueInput,
        include: Optional[types.CertificateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Certificate record.

        Parameters
        ----------
        where
            Certificate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The found Certificate record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        certificate = await Certificate.prisma().find_unique(
            where={
                'id': 1023081650,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CertificateWhereUniqueInput,
        include: Optional[types.CertificateInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Certificate record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Certificate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The found Certificate record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        certificate = await Certificate.prisma().find_unique_or_raise(
            where={
                'id': 327681027,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
        include: Optional[types.CertificateInclude] = None,
        order: Optional[Union[types.CertificateOrderByInput, List[types.CertificateOrderByInput]]] = None,
        distinct: Optional[List[types.CertificateScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Certificate records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Certificate records returned
        skip
            Ignore the first N results
        where
            Certificate filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Certificate model
        order
            Order the returned Certificate records by any field
        distinct
            Filter Certificate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Certificate]
            The list of all Certificate records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Certificate records
        certificates = await Certificate.prisma().find_many(take=10)

        # find the first 5 Certificate records ordered by the moduleId field
        certificates = await Certificate.prisma().find_many(
            take=5,
            order={
                'moduleId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
        include: Optional[types.CertificateInclude] = None,
        order: Optional[Union[types.CertificateOrderByInput, List[types.CertificateOrderByInput]]] = None,
        distinct: Optional[List[types.CertificateScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Certificate record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Certificate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Certificate model
        order
            Order the returned Certificate records by any field
        distinct
            Filter Certificate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Certificate
            The first Certificate record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Certificate record ordered by the fileUrl field
        certificate = await Certificate.prisma().find_first(
            skip=1,
            order={
                'fileUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
        include: Optional[types.CertificateInclude] = None,
        order: Optional[Union[types.CertificateOrderByInput, List[types.CertificateOrderByInput]]] = None,
        distinct: Optional[List[types.CertificateScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Certificate record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Certificate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Certificate model
        order
            Order the returned Certificate records by any field
        distinct
            Filter Certificate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Certificate
            The first Certificate record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Certificate record ordered by the issuedAt field
        certificate = await Certificate.prisma().find_first_or_raise(
            skip=1,
            order={
                'issuedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CertificateUpdateInput,
        where: types.CertificateWhereUniqueInput,
        include: Optional[types.CertificateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Certificate record.

        Parameters
        ----------
        data
            Certificate record data specifying what to update
        where
            Certificate filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The updated Certificate record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        certificate = await Certificate.prisma().update(
            where={
                'id': 527748992,
            },
            data={
                # data to update the Certificate record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CertificateWhereUniqueInput,
        data: types.CertificateUpsertInput,
        include: Optional[types.CertificateInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Certificate filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Certificate model

        Returns
        -------
        prisma.models.Certificate
            The created or updated Certificate record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        certificate = await Certificate.prisma().upsert(
            where={
                'id': 2029357497,
            },
            data={
                'create': {
                    'id': 2029357497,
                    'userId': 976832615,
                    'fileUrl': 'bgjgecfejc',
                },
                'update': {
                    'userId': 976832615,
                    'fileUrl': 'bgjgecfejc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CertificateUpdateManyMutationInput,
        where: types.CertificateWhereInput,
    ) -> int:
        """Update multiple Certificate records

        Parameters
        ----------
        data
            Certificate data to update the selected Certificate records to
        where
            Filter to select the Certificate records to update

        Returns
        -------
        int
            The total number of Certificate records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Certificate records
        total = await Certificate.prisma().update_many(
            data={
                'metadata': Json({'bdbifjhbbi': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Certificate records present in the database

        Parameters
        ----------
        select
            Select the Certificate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Certificate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CertificateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Certificate.prisma().count()

        # results: prisma.types.CertificateCountAggregateOutput
        results = await Certificate.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CertificateCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
    ) -> types.CertificateCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CertificateCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CertificateWhereInput] = None,
        cursor: Optional[types.CertificateWhereUniqueInput] = None,
    ) -> Union[int, types.CertificateCountAggregateOutput]:
        """Count the number of Certificate records present in the database

        Parameters
        ----------
        select
            Select the Certificate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Certificate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CertificateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Certificate.prisma().count()

        # results: prisma.types.CertificateCountAggregateOutput
        results = await Certificate.prisma().count(
            select={
                '_all': True,
                'deletedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CertificateCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CertificateWhereInput] = None
    ) -> int:
        """Delete multiple Certificate records.

        Parameters
        ----------
        where
            Optional Certificate filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Certificate records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Certificate records
        total = await Certificate.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CertificateScalarFieldKeys'],
        *,
        where: Optional['types.CertificateWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CertificateAvgAggregateInput'] = None,
        sum: Optional['types.CertificateSumAggregateInput'] = None,
        min: Optional['types.CertificateMinAggregateInput'] = None,
        max: Optional['types.CertificateMaxAggregateInput'] = None,
        having: Optional['types.CertificateScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CertificateCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CertificateScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CertificateScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CertificateGroupByOutput']:
        """Group Certificate records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Certificate fields to group records by
        where
            Certificate filter to select records
        take
            Limit the maximum number of Certificate records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CertificateGroupByOutput]
            A list of dictionaries representing the Certificate record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Certificate records by id values
        # and count how many records are in each group
        results = await Certificate.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Project]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Project.prisma().query_raw(
            'SELECT * FROM Project WHERE id = $1',
            2122112351,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Project
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Project.prisma().query_first(
            'SELECT * FROM Project WHERE title = $1',
            'bacejedaca',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectCreateInput,
        include: Optional[types.ProjectInclude] = None
    ) -> _PrismaModelT:
        """Create a new Project record.

        Parameters
        ----------
        data
            Project record data
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The created Project record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Project record from just the required fields
        project = await Project.prisma().create(
            data={
                # data to create a Project record
                'title': 'bhbhdahfaj',
                'slug': 'bfjibceaec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Project records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Project record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Project.prisma().create_many(
            data=[
                {
                    # data to create a Project record
                    'title': 'ibhgcdbgd',
                    'slug': 'badaffhddg',
                },
                {
                    # data to create a Project record
                    'title': 'bbdbfcfihd',
                    'slug': 'cbagggbji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Project record.

        Parameters
        ----------
        where
            Project filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The deleted Project record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().delete(
            where={
                'id': 1276057943,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Project record.

        Parameters
        ----------
        where
            Project filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The found Project record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().find_unique(
            where={
                'id': 745569348,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Project record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Project filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The found Project record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().find_unique_or_raise(
            where={
                'id': 307876141,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Project records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Project records returned
        skip
            Ignore the first N results
        where
            Project filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Project]
            The list of all Project records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Project records
        projects = await Project.prisma().find_many(take=10)

        # find the first 5 Project records ordered by the description field
        projects = await Project.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Project record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Project filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Project
            The first Project record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Project record ordered by the createdAt field
        project = await Project.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Project record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Project filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Project
            The first Project record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Project record ordered by the updatedAt field
        project = await Project.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectUpdateInput,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Project record.

        Parameters
        ----------
        data
            Project record data specifying what to update
        where
            Project filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The updated Project record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        project = await Project.prisma().update(
            where={
                'id': 1674049122,
            },
            data={
                # data to update the Project record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectWhereUniqueInput,
        data: types.ProjectUpsertInput,
        include: Optional[types.ProjectInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Project filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The created or updated Project record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().upsert(
            where={
                'id': 1526854643,
            },
            data={
                'create': {
                    'id': 1526854643,
                    'title': 'bbdbfcfihd',
                    'slug': 'cbagggbji',
                },
                'update': {
                    'title': 'bbdbfcfihd',
                    'slug': 'cbagggbji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectUpdateManyMutationInput,
        where: types.ProjectWhereInput,
    ) -> int:
        """Update multiple Project records

        Parameters
        ----------
        data
            Project data to update the selected Project records to
        where
            Filter to select the Project records to update

        Returns
        -------
        int
            The total number of Project records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Project records
        total = await Project.prisma().update_many(
            data={
                'deletedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Project records present in the database

        Parameters
        ----------
        select
            Select the Project fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Project filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Project.prisma().count()

        # results: prisma.types.ProjectCountAggregateOutput
        results = await Project.prisma().count(
            select={
                '_all': True,
                'organizationId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> types.ProjectCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectCountAggregateOutput]:
        """Count the number of Project records present in the database

        Parameters
        ----------
        select
            Select the Project fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Project filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Project.prisma().count()

        # results: prisma.types.ProjectCountAggregateOutput
        results = await Project.prisma().count(
            select={
                '_all': True,
                'ownerId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectWhereInput] = None
    ) -> int:
        """Delete multiple Project records.

        Parameters
        ----------
        where
            Optional Project filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Project records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Project records
        total = await Project.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectScalarFieldKeys'],
        *,
        where: Optional['types.ProjectWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectAvgAggregateInput'] = None,
        sum: Optional['types.ProjectSumAggregateInput'] = None,
        min: Optional['types.ProjectMinAggregateInput'] = None,
        max: Optional['types.ProjectMaxAggregateInput'] = None,
        having: Optional['types.ProjectScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectGroupByOutput']:
        """Group Project records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Project fields to group records by
        where
            Project filter to select records
        take
            Limit the maximum number of Project records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectGroupByOutput]
            A list of dictionaries representing the Project record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Project records by skills values
        # and count how many records are in each group
        results = await Project.prisma().group_by(
            ['skills'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProposalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Proposal]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Proposal.prisma().query_raw(
            'SELECT * FROM Proposal WHERE id = $1',
            958077104,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Proposal
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Proposal.prisma().query_first(
            'SELECT * FROM Proposal WHERE projectId = $1',
            1513050921,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProposalCreateInput,
        include: Optional[types.ProposalInclude] = None
    ) -> _PrismaModelT:
        """Create a new Proposal record.

        Parameters
        ----------
        data
            Proposal record data
        include
            Specifies which relations should be loaded on the returned Proposal model

        Returns
        -------
        prisma.models.Proposal
            The created Proposal record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Proposal record from just the required fields
        proposal = await Proposal.prisma().create(
            data={
                # data to create a Proposal record
                'projectId': 204674734,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProposalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Proposal records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Proposal record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Proposal.prisma().create_many(
            data=[
                {
                    # data to create a Proposal record
                    'projectId': 2067651663,
                },
                {
                    # data to create a Proposal record
                    'projectId': 1183911900,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProposalWhereUniqueInput,
        include: Optional[types.ProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Proposal record.

        Parameters
        ----------
        where
            Proposal filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Proposal model

        Returns
        -------
        prisma.models.Proposal
            The deleted Proposal record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        proposal = await Proposal.prisma().delete(
            where={
                'id': 1589704933,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProposalWhereUniqueInput,
        include: Optional[types.ProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Proposal record.

        Parameters
        ----------
        where
            Proposal filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Proposal model

        Returns
        -------
        prisma.models.Proposal
            The found Proposal record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        proposal = await Proposal.prisma().find_unique(
            where={
                'id': 1243475898,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProposalWhereUniqueInput,
        include: Optional[types.ProposalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Proposal record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Proposal filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Proposal model

        Returns
        -------
        prisma.models.Proposal
            The found Proposal record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        proposal = await Proposal.prisma().find_unique_or_raise(
            where={
                'id': 1369828971,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProposalWhereInput] = None,
        cursor: Optional[types.ProposalWhereUniqueInput] = None,
        include: Optional[types.ProposalInclude] = None,
        order: Optional[Union[types.ProposalOrderByInput, List[types.ProposalOrderByInput]]] = None,
        distinct: Optional[List[types.ProposalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Proposal records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Proposal records returned
        skip
            Ignore the first N results
        where
            Proposal filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Proposal model
        order
            Order the returned Proposal records by any field
        distinct
            Filter Proposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Proposal]
            The list of all Proposal records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Proposal records
        proposals = await Proposal.prisma().find_many(take=10)

        # find the first 5 Proposal records ordered by the freelancerId field
        proposals = await Proposal.prisma().find_many(
            take=5,
            order={
                'freelancerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProposalWhereInput] = None,
        cursor: Optional[types.ProposalWhereUniqueInput] = None,
        include: Optional[types.ProposalInclude] = None,
        order: Optional[Union[types.ProposalOrderByInput, List[types.ProposalOrderByInput]]] = None,
        distinct: Optional[List[types.ProposalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Proposal record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Proposal filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Proposal model
        order
            Order the returned Proposal records by any field
        distinct
            Filter Proposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Proposal
            The first Proposal record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Proposal record ordered by the message field
        proposal = await Proposal.prisma().find_first(
            skip=1,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProposalWhereInput] = None,
        cursor: Optional[types.ProposalWhereUniqueInput] = None,
        include: Optional[types.ProposalInclude] = None,
        order: Optional[Union[types.ProposalOrderByInput, List[types.ProposalOrderByInput]]] = None,
        distinct: Optional[List[types.ProposalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Proposal record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Proposal filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Proposal model
        order
            Order the returned Proposal records by any field
        distinct
            Filter Proposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Proposal
            The first Proposal record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Proposal record ordered by the amountCents field
        proposal = await Proposal.prisma().find_first_or_raise(
            skip=1,
            order={
                'amountCents': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProposalUpdateInput,
        where: types.ProposalWhereUniqueInput,
        include: Optional[types.ProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Proposal record.

        Parameters
        ----------
        data
            Proposal record data specifying what to update
        where
            Proposal filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Proposal model

        Returns
        -------
        prisma.models.Proposal
            The updated Proposal record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        proposal = await Proposal.prisma().update(
            where={
                'id': 1678593480,
            },
            data={
                # data to update the Proposal record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProposalWhereUniqueInput,
        data: types.ProposalUpsertInput,
        include: Optional[types.ProposalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Proposal filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Proposal model

        Returns
        -------
        prisma.models.Proposal
            The created or updated Proposal record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        proposal = await Proposal.prisma().upsert(
            where={
                'id': 403521121,
            },
            data={
                'create': {
                    'id': 403521121,
                    'projectId': 1183911900,
                },
                'update': {
                    'projectId': 1183911900,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProposalUpdateManyMutationInput,
        where: types.ProposalWhereInput,
    ) -> int:
        """Update multiple Proposal records

        Parameters
        ----------
        data
            Proposal data to update the selected Proposal records to
        where
            Filter to select the Proposal records to update

        Returns
        -------
        int
            The total number of Proposal records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Proposal records
        total = await Proposal.prisma().update_many(
            data={
                'status': 'geihgahba'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProposalWhereInput] = None,
        cursor: Optional[types.ProposalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Proposal records present in the database

        Parameters
        ----------
        select
            Select the Proposal fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Proposal filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProposalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Proposal.prisma().count()

        # results: prisma.types.ProposalCountAggregateOutput
        results = await Proposal.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProposalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProposalWhereInput] = None,
        cursor: Optional[types.ProposalWhereUniqueInput] = None,
    ) -> types.ProposalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProposalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProposalWhereInput] = None,
        cursor: Optional[types.ProposalWhereUniqueInput] = None,
    ) -> Union[int, types.ProposalCountAggregateOutput]:
        """Count the number of Proposal records present in the database

        Parameters
        ----------
        select
            Select the Proposal fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Proposal filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProposalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Proposal.prisma().count()

        # results: prisma.types.ProposalCountAggregateOutput
        results = await Proposal.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProposalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProposalWhereInput] = None
    ) -> int:
        """Delete multiple Proposal records.

        Parameters
        ----------
        where
            Optional Proposal filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Proposal records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Proposal records
        total = await Proposal.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProposalScalarFieldKeys'],
        *,
        where: Optional['types.ProposalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProposalAvgAggregateInput'] = None,
        sum: Optional['types.ProposalSumAggregateInput'] = None,
        min: Optional['types.ProposalMinAggregateInput'] = None,
        max: Optional['types.ProposalMaxAggregateInput'] = None,
        having: Optional['types.ProposalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProposalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProposalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProposalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProposalGroupByOutput']:
        """Group Proposal records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Proposal fields to group records by
        where
            Proposal filter to select records
        take
            Limit the maximum number of Proposal records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProposalGroupByOutput]
            A list of dictionaries representing the Proposal record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Proposal records by deletedAt values
        # and count how many records are in each group
        results = await Proposal.prisma().group_by(
            ['deletedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContractActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Contract]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Contract.prisma().query_raw(
            'SELECT * FROM Contract WHERE id = $1',
            607323719,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Contract
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Contract.prisma().query_first(
            'SELECT * FROM Contract WHERE projectId = $1',
            1468890740,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ContractCreateInput,
        include: Optional[types.ContractInclude] = None
    ) -> _PrismaModelT:
        """Create a new Contract record.

        Parameters
        ----------
        data
            Contract record data
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The created Contract record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Contract record from just the required fields
        contract = await Contract.prisma().create(
            data={
                # data to create a Contract record
                'projectId': 629039005,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ContractCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Contract records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Contract record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Contract.prisma().create_many(
            data=[
                {
                    # data to create a Contract record
                    'projectId': 1214168082,
                },
                {
                    # data to create a Contract record
                    'projectId': 898613219,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Contract record.

        Parameters
        ----------
        where
            Contract filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The deleted Contract record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().delete(
            where={
                'id': 658378208,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Contract record.

        Parameters
        ----------
        where
            Contract filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The found Contract record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().find_unique(
            where={
                'id': 954620057,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Contract record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Contract filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The found Contract record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().find_unique_or_raise(
            where={
                'id': 1214809950,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Contract records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Contract records returned
        skip
            Ignore the first N results
        where
            Contract filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Contract]
            The list of all Contract records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Contract records
        contracts = await Contract.prisma().find_many(take=10)

        # find the first 5 Contract records ordered by the freelancerId field
        contracts = await Contract.prisma().find_many(
            take=5,
            order={
                'freelancerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Contract record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contract filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contract
            The first Contract record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contract record ordered by the clientId field
        contract = await Contract.prisma().find_first(
            skip=1,
            order={
                'clientId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
        include: Optional[types.ContractInclude] = None,
        order: Optional[Union[types.ContractOrderByInput, List[types.ContractOrderByInput]]] = None,
        distinct: Optional[List[types.ContractScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Contract record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contract filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contract model
        order
            Order the returned Contract records by any field
        distinct
            Filter Contract records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contract
            The first Contract record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contract record ordered by the terms field
        contract = await Contract.prisma().find_first_or_raise(
            skip=1,
            order={
                'terms': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ContractUpdateInput,
        where: types.ContractWhereUniqueInput,
        include: Optional[types.ContractInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Contract record.

        Parameters
        ----------
        data
            Contract record data specifying what to update
        where
            Contract filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The updated Contract record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contract = await Contract.prisma().update(
            where={
                'id': 1047820095,
            },
            data={
                # data to update the Contract record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ContractWhereUniqueInput,
        data: types.ContractUpsertInput,
        include: Optional[types.ContractInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Contract filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Contract model

        Returns
        -------
        prisma.models.Contract
            The created or updated Contract record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contract = await Contract.prisma().upsert(
            where={
                'id': 1302734860,
            },
            data={
                'create': {
                    'id': 1302734860,
                    'projectId': 898613219,
                },
                'update': {
                    'projectId': 898613219,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ContractUpdateManyMutationInput,
        where: types.ContractWhereInput,
    ) -> int:
        """Update multiple Contract records

        Parameters
        ----------
        data
            Contract data to update the selected Contract records to
        where
            Filter to select the Contract records to update

        Returns
        -------
        int
            The total number of Contract records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Contract records
        total = await Contract.prisma().update_many(
            data={
                'startDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Contract records present in the database

        Parameters
        ----------
        select
            Select the Contract fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contract filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContractCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contract.prisma().count()

        # results: prisma.types.ContractCountAggregateOutput
        results = await Contract.prisma().count(
            select={
                '_all': True,
                'endDate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ContractCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> types.ContractCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ContractCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContractWhereInput] = None,
        cursor: Optional[types.ContractWhereUniqueInput] = None,
    ) -> Union[int, types.ContractCountAggregateOutput]:
        """Count the number of Contract records present in the database

        Parameters
        ----------
        select
            Select the Contract fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contract filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContractCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contract.prisma().count()

        # results: prisma.types.ContractCountAggregateOutput
        results = await Contract.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContractCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ContractWhereInput] = None
    ) -> int:
        """Delete multiple Contract records.

        Parameters
        ----------
        where
            Optional Contract filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Contract records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Contract records
        total = await Contract.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ContractScalarFieldKeys'],
        *,
        where: Optional['types.ContractWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContractAvgAggregateInput'] = None,
        sum: Optional['types.ContractSumAggregateInput'] = None,
        min: Optional['types.ContractMinAggregateInput'] = None,
        max: Optional['types.ContractMaxAggregateInput'] = None,
        having: Optional['types.ContractScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContractCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContractScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ContractScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ContractGroupByOutput']:
        """Group Contract records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Contract fields to group records by
        where
            Contract filter to select records
        take
            Limit the maximum number of Contract records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContractGroupByOutput]
            A list of dictionaries representing the Contract record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Contract records by createdAt values
        # and count how many records are in each group
        results = await Contract.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DeliveryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Delivery]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Delivery.prisma().query_raw(
            'SELECT * FROM Delivery WHERE id = $1',
            893052245,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Delivery
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Delivery.prisma().query_first(
            'SELECT * FROM Delivery WHERE contractId = $1',
            280083306,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DeliveryCreateInput,
        include: Optional[types.DeliveryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Delivery record.

        Parameters
        ----------
        data
            Delivery record data
        include
            Specifies which relations should be loaded on the returned Delivery model

        Returns
        -------
        prisma.models.Delivery
            The created Delivery record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Delivery record from just the required fields
        delivery = await Delivery.prisma().create(
            data={
                # data to create a Delivery record
                'contractId': 549668955,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DeliveryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Delivery records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Delivery record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Delivery.prisma().create_many(
            data=[
                {
                    # data to create a Delivery record
                    'contractId': 76790008,
                },
                {
                    # data to create a Delivery record
                    'contractId': 2098299345,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DeliveryWhereUniqueInput,
        include: Optional[types.DeliveryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Delivery record.

        Parameters
        ----------
        where
            Delivery filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Delivery model

        Returns
        -------
        prisma.models.Delivery
            The deleted Delivery record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        delivery = await Delivery.prisma().delete(
            where={
                'id': 245900342,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DeliveryWhereUniqueInput,
        include: Optional[types.DeliveryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Delivery record.

        Parameters
        ----------
        where
            Delivery filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Delivery model

        Returns
        -------
        prisma.models.Delivery
            The found Delivery record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        delivery = await Delivery.prisma().find_unique(
            where={
                'id': 811863863,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DeliveryWhereUniqueInput,
        include: Optional[types.DeliveryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Delivery record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Delivery filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Delivery model

        Returns
        -------
        prisma.models.Delivery
            The found Delivery record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        delivery = await Delivery.prisma().find_unique_or_raise(
            where={
                'id': 1388801188,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DeliveryWhereInput] = None,
        cursor: Optional[types.DeliveryWhereUniqueInput] = None,
        include: Optional[types.DeliveryInclude] = None,
        order: Optional[Union[types.DeliveryOrderByInput, List[types.DeliveryOrderByInput]]] = None,
        distinct: Optional[List[types.DeliveryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Delivery records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Delivery records returned
        skip
            Ignore the first N results
        where
            Delivery filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Delivery model
        order
            Order the returned Delivery records by any field
        distinct
            Filter Delivery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Delivery]
            The list of all Delivery records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Delivery records
        deliverys = await Delivery.prisma().find_many(take=10)

        # find the first 5 Delivery records ordered by the description field
        deliverys = await Delivery.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DeliveryWhereInput] = None,
        cursor: Optional[types.DeliveryWhereUniqueInput] = None,
        include: Optional[types.DeliveryInclude] = None,
        order: Optional[Union[types.DeliveryOrderByInput, List[types.DeliveryOrderByInput]]] = None,
        distinct: Optional[List[types.DeliveryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Delivery record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Delivery filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Delivery model
        order
            Order the returned Delivery records by any field
        distinct
            Filter Delivery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Delivery
            The first Delivery record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Delivery record ordered by the deliveredAt field
        delivery = await Delivery.prisma().find_first(
            skip=1,
            order={
                'deliveredAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DeliveryWhereInput] = None,
        cursor: Optional[types.DeliveryWhereUniqueInput] = None,
        include: Optional[types.DeliveryInclude] = None,
        order: Optional[Union[types.DeliveryOrderByInput, List[types.DeliveryOrderByInput]]] = None,
        distinct: Optional[List[types.DeliveryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Delivery record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Delivery filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Delivery model
        order
            Order the returned Delivery records by any field
        distinct
            Filter Delivery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Delivery
            The first Delivery record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Delivery record ordered by the files field
        delivery = await Delivery.prisma().find_first_or_raise(
            skip=1,
            order={
                'files': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DeliveryUpdateInput,
        where: types.DeliveryWhereUniqueInput,
        include: Optional[types.DeliveryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Delivery record.

        Parameters
        ----------
        data
            Delivery record data specifying what to update
        where
            Delivery filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Delivery model

        Returns
        -------
        prisma.models.Delivery
            The updated Delivery record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        delivery = await Delivery.prisma().update(
            where={
                'id': 752577037,
            },
            data={
                # data to update the Delivery record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DeliveryWhereUniqueInput,
        data: types.DeliveryUpsertInput,
        include: Optional[types.DeliveryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Delivery filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Delivery model

        Returns
        -------
        prisma.models.Delivery
            The created or updated Delivery record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        delivery = await Delivery.prisma().upsert(
            where={
                'id': 1187663298,
            },
            data={
                'create': {
                    'id': 1187663298,
                    'contractId': 2098299345,
                },
                'update': {
                    'contractId': 2098299345,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DeliveryUpdateManyMutationInput,
        where: types.DeliveryWhereInput,
    ) -> int:
        """Update multiple Delivery records

        Parameters
        ----------
        data
            Delivery data to update the selected Delivery records to
        where
            Filter to select the Delivery records to update

        Returns
        -------
        int
            The total number of Delivery records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Delivery records
        total = await Delivery.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DeliveryWhereInput] = None,
        cursor: Optional[types.DeliveryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Delivery records present in the database

        Parameters
        ----------
        select
            Select the Delivery fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Delivery filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DeliveryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Delivery.prisma().count()

        # results: prisma.types.DeliveryCountAggregateOutput
        results = await Delivery.prisma().count(
            select={
                '_all': True,
                'deletedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DeliveryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DeliveryWhereInput] = None,
        cursor: Optional[types.DeliveryWhereUniqueInput] = None,
    ) -> types.DeliveryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DeliveryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DeliveryWhereInput] = None,
        cursor: Optional[types.DeliveryWhereUniqueInput] = None,
    ) -> Union[int, types.DeliveryCountAggregateOutput]:
        """Count the number of Delivery records present in the database

        Parameters
        ----------
        select
            Select the Delivery fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Delivery filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DeliveryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Delivery.prisma().count()

        # results: prisma.types.DeliveryCountAggregateOutput
        results = await Delivery.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DeliveryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DeliveryWhereInput] = None
    ) -> int:
        """Delete multiple Delivery records.

        Parameters
        ----------
        where
            Optional Delivery filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Delivery records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Delivery records
        total = await Delivery.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DeliveryScalarFieldKeys'],
        *,
        where: Optional['types.DeliveryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DeliveryAvgAggregateInput'] = None,
        sum: Optional['types.DeliverySumAggregateInput'] = None,
        min: Optional['types.DeliveryMinAggregateInput'] = None,
        max: Optional['types.DeliveryMaxAggregateInput'] = None,
        having: Optional['types.DeliveryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DeliveryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DeliveryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DeliveryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DeliveryGroupByOutput']:
        """Group Delivery records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Delivery fields to group records by
        where
            Delivery filter to select records
        take
            Limit the maximum number of Delivery records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DeliveryGroupByOutput]
            A list of dictionaries representing the Delivery record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Delivery records by contractId values
        # and count how many records are in each group
        results = await Delivery.prisma().group_by(
            ['contractId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserSkillActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserSkill]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserSkill.prisma().query_raw(
            'SELECT * FROM UserSkill WHERE id = $1',
            769681363,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserSkill
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserSkill.prisma().query_first(
            'SELECT * FROM UserSkill WHERE userId = $1',
            1214295824,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserSkillCreateInput,
        include: Optional[types.UserSkillInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserSkill record.

        Parameters
        ----------
        data
            UserSkill record data
        include
            Specifies which relations should be loaded on the returned UserSkill model

        Returns
        -------
        prisma.models.UserSkill
            The created UserSkill record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserSkill record from just the required fields
        userskill = await UserSkill.prisma().create(
            data={
                # data to create a UserSkill record
                'userId': 1021417993,
                'name': 'dfbfaddhe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserSkillCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserSkill records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserSkill record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserSkill.prisma().create_many(
            data=[
                {
                    # data to create a UserSkill record
                    'userId': 1321184815,
                    'name': 'dgjhdcggi',
                },
                {
                    # data to create a UserSkill record
                    'userId': 1191235013,
                    'name': 'gchfgbcec',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserSkillWhereUniqueInput,
        include: Optional[types.UserSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserSkill record.

        Parameters
        ----------
        where
            UserSkill filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserSkill model

        Returns
        -------
        prisma.models.UserSkill
            The deleted UserSkill record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userskill = await UserSkill.prisma().delete(
            where={
                'id': 1872952907,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserSkillWhereUniqueInput,
        include: Optional[types.UserSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserSkill record.

        Parameters
        ----------
        where
            UserSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSkill model

        Returns
        -------
        prisma.models.UserSkill
            The found UserSkill record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userskill = await UserSkill.prisma().find_unique(
            where={
                'id': 1793282088,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserSkillWhereUniqueInput,
        include: Optional[types.UserSkillInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserSkill record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSkill model

        Returns
        -------
        prisma.models.UserSkill
            The found UserSkill record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userskill = await UserSkill.prisma().find_unique_or_raise(
            where={
                'id': 1814397249,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSkillWhereInput] = None,
        cursor: Optional[types.UserSkillWhereUniqueInput] = None,
        include: Optional[types.UserSkillInclude] = None,
        order: Optional[Union[types.UserSkillOrderByInput, List[types.UserSkillOrderByInput]]] = None,
        distinct: Optional[List[types.UserSkillScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserSkill records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserSkill records returned
        skip
            Ignore the first N results
        where
            UserSkill filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSkill model
        order
            Order the returned UserSkill records by any field
        distinct
            Filter UserSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserSkill]
            The list of all UserSkill records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserSkill records
        userskills = await UserSkill.prisma().find_many(take=10)

        # find the first 5 UserSkill records ordered by the name field
        userskills = await UserSkill.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSkillWhereInput] = None,
        cursor: Optional[types.UserSkillWhereUniqueInput] = None,
        include: Optional[types.UserSkillInclude] = None,
        order: Optional[Union[types.UserSkillOrderByInput, List[types.UserSkillOrderByInput]]] = None,
        distinct: Optional[List[types.UserSkillScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserSkill record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSkill model
        order
            Order the returned UserSkill records by any field
        distinct
            Filter UserSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSkill
            The first UserSkill record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSkill record ordered by the createdAt field
        userskill = await UserSkill.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSkillWhereInput] = None,
        cursor: Optional[types.UserSkillWhereUniqueInput] = None,
        include: Optional[types.UserSkillInclude] = None,
        order: Optional[Union[types.UserSkillOrderByInput, List[types.UserSkillOrderByInput]]] = None,
        distinct: Optional[List[types.UserSkillScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserSkill record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSkill model
        order
            Order the returned UserSkill records by any field
        distinct
            Filter UserSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSkill
            The first UserSkill record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSkill record ordered by the id field
        userskill = await UserSkill.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserSkillUpdateInput,
        where: types.UserSkillWhereUniqueInput,
        include: Optional[types.UserSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserSkill record.

        Parameters
        ----------
        data
            UserSkill record data specifying what to update
        where
            UserSkill filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserSkill model

        Returns
        -------
        prisma.models.UserSkill
            The updated UserSkill record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userskill = await UserSkill.prisma().update(
            where={
                'id': 1923090150,
            },
            data={
                # data to update the UserSkill record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserSkillWhereUniqueInput,
        data: types.UserSkillUpsertInput,
        include: Optional[types.UserSkillInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserSkill filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserSkill model

        Returns
        -------
        prisma.models.UserSkill
            The created or updated UserSkill record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userskill = await UserSkill.prisma().upsert(
            where={
                'id': 1277244455,
            },
            data={
                'create': {
                    'id': 1277244455,
                    'userId': 1191235013,
                    'name': 'gchfgbcec',
                },
                'update': {
                    'userId': 1191235013,
                    'name': 'gchfgbcec',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserSkillUpdateManyMutationInput,
        where: types.UserSkillWhereInput,
    ) -> int:
        """Update multiple UserSkill records

        Parameters
        ----------
        data
            UserSkill data to update the selected UserSkill records to
        where
            Filter to select the UserSkill records to update

        Returns
        -------
        int
            The total number of UserSkill records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserSkill records
        total = await UserSkill.prisma().update_many(
            data={
                'userId': 1160857300
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSkillWhereInput] = None,
        cursor: Optional[types.UserSkillWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserSkill records present in the database

        Parameters
        ----------
        select
            Select the UserSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSkill.prisma().count()

        # results: prisma.types.UserSkillCountAggregateOutput
        results = await UserSkill.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserSkillCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSkillWhereInput] = None,
        cursor: Optional[types.UserSkillWhereUniqueInput] = None,
    ) -> types.UserSkillCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserSkillCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSkillWhereInput] = None,
        cursor: Optional[types.UserSkillWhereUniqueInput] = None,
    ) -> Union[int, types.UserSkillCountAggregateOutput]:
        """Count the number of UserSkill records present in the database

        Parameters
        ----------
        select
            Select the UserSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSkill.prisma().count()

        # results: prisma.types.UserSkillCountAggregateOutput
        results = await UserSkill.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserSkillCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserSkillWhereInput] = None
    ) -> int:
        """Delete multiple UserSkill records.

        Parameters
        ----------
        where
            Optional UserSkill filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserSkill records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserSkill records
        total = await UserSkill.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserSkillScalarFieldKeys'],
        *,
        where: Optional['types.UserSkillWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserSkillAvgAggregateInput'] = None,
        sum: Optional['types.UserSkillSumAggregateInput'] = None,
        min: Optional['types.UserSkillMinAggregateInput'] = None,
        max: Optional['types.UserSkillMaxAggregateInput'] = None,
        having: Optional['types.UserSkillScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserSkillCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserSkillScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserSkillScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserSkillGroupByOutput']:
        """Group UserSkill records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserSkill fields to group records by
        where
            UserSkill filter to select records
        take
            Limit the maximum number of UserSkill records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserSkillGroupByOutput]
            A list of dictionaries representing the UserSkill record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserSkill records by id values
        # and count how many records are in each group
        results = await UserSkill.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DatasetActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Dataset]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Dataset.prisma().query_raw(
            'SELECT * FROM Dataset WHERE id = $1',
            361230461,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Dataset
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Dataset.prisma().query_first(
            'SELECT * FROM Dataset WHERE description = $1',
            'beagfbbjig',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DatasetCreateInput,
        include: Optional[types.DatasetInclude] = None
    ) -> _PrismaModelT:
        """Create a new Dataset record.

        Parameters
        ----------
        data
            Dataset record data
        include
            Specifies which relations should be loaded on the returned Dataset model

        Returns
        -------
        prisma.models.Dataset
            The created Dataset record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Dataset record from just the required fields
        dataset = await Dataset.prisma().create(
            data={
                # data to create a Dataset record
                'name': 'beicihhijb',
                'slug': 'fgggcdcjg',
                'sourceType': 'ccjbbjigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DatasetCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Dataset records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Dataset record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Dataset.prisma().create_many(
            data=[
                {
                    # data to create a Dataset record
                    'name': 'bhfaabbaha',
                    'slug': 'ebajedhhf',
                    'sourceType': 'jajacedge',
                },
                {
                    # data to create a Dataset record
                    'name': 'hffgbabgf',
                    'slug': 'biacbiieja',
                    'sourceType': 'cjejbgbff',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DatasetWhereUniqueInput,
        include: Optional[types.DatasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Dataset record.

        Parameters
        ----------
        where
            Dataset filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Dataset model

        Returns
        -------
        prisma.models.Dataset
            The deleted Dataset record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset = await Dataset.prisma().delete(
            where={
                'id': 564073304,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DatasetWhereUniqueInput,
        include: Optional[types.DatasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Dataset record.

        Parameters
        ----------
        where
            Dataset filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Dataset model

        Returns
        -------
        prisma.models.Dataset
            The found Dataset record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset = await Dataset.prisma().find_unique(
            where={
                'id': 380648625,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DatasetWhereUniqueInput,
        include: Optional[types.DatasetInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Dataset record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Dataset filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Dataset model

        Returns
        -------
        prisma.models.Dataset
            The found Dataset record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset = await Dataset.prisma().find_unique_or_raise(
            where={
                'id': 1030616470,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DatasetWhereInput] = None,
        cursor: Optional[types.DatasetWhereUniqueInput] = None,
        include: Optional[types.DatasetInclude] = None,
        order: Optional[Union[types.DatasetOrderByInput, List[types.DatasetOrderByInput]]] = None,
        distinct: Optional[List[types.DatasetScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Dataset records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Dataset records returned
        skip
            Ignore the first N results
        where
            Dataset filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Dataset model
        order
            Order the returned Dataset records by any field
        distinct
            Filter Dataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Dataset]
            The list of all Dataset records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Dataset records
        datasets = await Dataset.prisma().find_many(take=10)

        # find the first 5 Dataset records ordered by the userId field
        datasets = await Dataset.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DatasetWhereInput] = None,
        cursor: Optional[types.DatasetWhereUniqueInput] = None,
        include: Optional[types.DatasetInclude] = None,
        order: Optional[Union[types.DatasetOrderByInput, List[types.DatasetOrderByInput]]] = None,
        distinct: Optional[List[types.DatasetScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Dataset record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Dataset filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Dataset model
        order
            Order the returned Dataset records by any field
        distinct
            Filter Dataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Dataset
            The first Dataset record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Dataset record ordered by the createdAt field
        dataset = await Dataset.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DatasetWhereInput] = None,
        cursor: Optional[types.DatasetWhereUniqueInput] = None,
        include: Optional[types.DatasetInclude] = None,
        order: Optional[Union[types.DatasetOrderByInput, List[types.DatasetOrderByInput]]] = None,
        distinct: Optional[List[types.DatasetScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Dataset record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Dataset filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Dataset model
        order
            Order the returned Dataset records by any field
        distinct
            Filter Dataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Dataset
            The first Dataset record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Dataset record ordered by the updatedAt field
        dataset = await Dataset.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DatasetUpdateInput,
        where: types.DatasetWhereUniqueInput,
        include: Optional[types.DatasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Dataset record.

        Parameters
        ----------
        data
            Dataset record data specifying what to update
        where
            Dataset filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Dataset model

        Returns
        -------
        prisma.models.Dataset
            The updated Dataset record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        dataset = await Dataset.prisma().update(
            where={
                'id': 816411927,
            },
            data={
                # data to update the Dataset record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DatasetWhereUniqueInput,
        data: types.DatasetUpsertInput,
        include: Optional[types.DatasetInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Dataset filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Dataset model

        Returns
        -------
        prisma.models.Dataset
            The created or updated Dataset record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dataset = await Dataset.prisma().upsert(
            where={
                'id': 1084099844,
            },
            data={
                'create': {
                    'id': 1084099844,
                    'name': 'hffgbabgf',
                    'slug': 'biacbiieja',
                    'sourceType': 'cjejbgbff',
                },
                'update': {
                    'name': 'hffgbabgf',
                    'slug': 'biacbiieja',
                    'sourceType': 'cjejbgbff',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DatasetUpdateManyMutationInput,
        where: types.DatasetWhereInput,
    ) -> int:
        """Update multiple Dataset records

        Parameters
        ----------
        data
            Dataset data to update the selected Dataset records to
        where
            Filter to select the Dataset records to update

        Returns
        -------
        int
            The total number of Dataset records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Dataset records
        total = await Dataset.prisma().update_many(
            data={
                'deletedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DatasetWhereInput] = None,
        cursor: Optional[types.DatasetWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Dataset records present in the database

        Parameters
        ----------
        select
            Select the Dataset fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Dataset filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DatasetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Dataset.prisma().count()

        # results: prisma.types.DatasetCountAggregateOutput
        results = await Dataset.prisma().count(
            select={
                '_all': True,
                'filePath': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DatasetCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DatasetWhereInput] = None,
        cursor: Optional[types.DatasetWhereUniqueInput] = None,
    ) -> types.DatasetCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DatasetCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DatasetWhereInput] = None,
        cursor: Optional[types.DatasetWhereUniqueInput] = None,
    ) -> Union[int, types.DatasetCountAggregateOutput]:
        """Count the number of Dataset records present in the database

        Parameters
        ----------
        select
            Select the Dataset fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Dataset filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DatasetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Dataset.prisma().count()

        # results: prisma.types.DatasetCountAggregateOutput
        results = await Dataset.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DatasetCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DatasetWhereInput] = None
    ) -> int:
        """Delete multiple Dataset records.

        Parameters
        ----------
        where
            Optional Dataset filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Dataset records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Dataset records
        total = await Dataset.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DatasetScalarFieldKeys'],
        *,
        where: Optional['types.DatasetWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DatasetAvgAggregateInput'] = None,
        sum: Optional['types.DatasetSumAggregateInput'] = None,
        min: Optional['types.DatasetMinAggregateInput'] = None,
        max: Optional['types.DatasetMaxAggregateInput'] = None,
        having: Optional['types.DatasetScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DatasetCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DatasetScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DatasetScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DatasetGroupByOutput']:
        """Group Dataset records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Dataset fields to group records by
        where
            Dataset filter to select records
        take
            Limit the maximum number of Dataset records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DatasetGroupByOutput]
            A list of dictionaries representing the Dataset record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Dataset records by name values
        # and count how many records are in each group
        results = await Dataset.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DashboardActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Dashboard]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Dashboard.prisma().query_raw(
            'SELECT * FROM Dashboard WHERE id = $1',
            1079702253,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Dashboard
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Dashboard.prisma().query_first(
            'SELECT * FROM Dashboard WHERE title = $1',
            'hffhfabhi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DashboardCreateInput,
        include: Optional[types.DashboardInclude] = None
    ) -> _PrismaModelT:
        """Create a new Dashboard record.

        Parameters
        ----------
        data
            Dashboard record data
        include
            Specifies which relations should be loaded on the returned Dashboard model

        Returns
        -------
        prisma.models.Dashboard
            The created Dashboard record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Dashboard record from just the required fields
        dashboard = await Dashboard.prisma().create(
            data={
                # data to create a Dashboard record
                'title': 'bbcigiadhb',
                'slug': 'cfjagbbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DashboardCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Dashboard records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Dashboard record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Dashboard.prisma().create_many(
            data=[
                {
                    # data to create a Dashboard record
                    'title': 'bbbfhdidef',
                    'slug': 'bdadhibhec',
                },
                {
                    # data to create a Dashboard record
                    'title': 'bfhdjaiejf',
                    'slug': 'bbjfijjadg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DashboardWhereUniqueInput,
        include: Optional[types.DashboardInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Dashboard record.

        Parameters
        ----------
        where
            Dashboard filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Dashboard model

        Returns
        -------
        prisma.models.Dashboard
            The deleted Dashboard record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dashboard = await Dashboard.prisma().delete(
            where={
                'id': 739021477,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DashboardWhereUniqueInput,
        include: Optional[types.DashboardInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Dashboard record.

        Parameters
        ----------
        where
            Dashboard filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Dashboard model

        Returns
        -------
        prisma.models.Dashboard
            The found Dashboard record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dashboard = await Dashboard.prisma().find_unique(
            where={
                'id': 1722214010,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DashboardWhereUniqueInput,
        include: Optional[types.DashboardInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Dashboard record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Dashboard filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Dashboard model

        Returns
        -------
        prisma.models.Dashboard
            The found Dashboard record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dashboard = await Dashboard.prisma().find_unique_or_raise(
            where={
                'id': 1269136939,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DashboardWhereInput] = None,
        cursor: Optional[types.DashboardWhereUniqueInput] = None,
        include: Optional[types.DashboardInclude] = None,
        order: Optional[Union[types.DashboardOrderByInput, List[types.DashboardOrderByInput]]] = None,
        distinct: Optional[List[types.DashboardScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Dashboard records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Dashboard records returned
        skip
            Ignore the first N results
        where
            Dashboard filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Dashboard model
        order
            Order the returned Dashboard records by any field
        distinct
            Filter Dashboard records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Dashboard]
            The list of all Dashboard records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Dashboard records
        dashboards = await Dashboard.prisma().find_many(take=10)

        # find the first 5 Dashboard records ordered by the description field
        dashboards = await Dashboard.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DashboardWhereInput] = None,
        cursor: Optional[types.DashboardWhereUniqueInput] = None,
        include: Optional[types.DashboardInclude] = None,
        order: Optional[Union[types.DashboardOrderByInput, List[types.DashboardOrderByInput]]] = None,
        distinct: Optional[List[types.DashboardScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Dashboard record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Dashboard filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Dashboard model
        order
            Order the returned Dashboard records by any field
        distinct
            Filter Dashboard records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Dashboard
            The first Dashboard record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Dashboard record ordered by the createdAt field
        dashboard = await Dashboard.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DashboardWhereInput] = None,
        cursor: Optional[types.DashboardWhereUniqueInput] = None,
        include: Optional[types.DashboardInclude] = None,
        order: Optional[Union[types.DashboardOrderByInput, List[types.DashboardOrderByInput]]] = None,
        distinct: Optional[List[types.DashboardScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Dashboard record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Dashboard filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Dashboard model
        order
            Order the returned Dashboard records by any field
        distinct
            Filter Dashboard records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Dashboard
            The first Dashboard record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Dashboard record ordered by the updatedAt field
        dashboard = await Dashboard.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DashboardUpdateInput,
        where: types.DashboardWhereUniqueInput,
        include: Optional[types.DashboardInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Dashboard record.

        Parameters
        ----------
        data
            Dashboard record data specifying what to update
        where
            Dashboard filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Dashboard model

        Returns
        -------
        prisma.models.Dashboard
            The updated Dashboard record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        dashboard = await Dashboard.prisma().update(
            where={
                'id': 573178504,
            },
            data={
                # data to update the Dashboard record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DashboardWhereUniqueInput,
        data: types.DashboardUpsertInput,
        include: Optional[types.DashboardInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Dashboard filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Dashboard model

        Returns
        -------
        prisma.models.Dashboard
            The created or updated Dashboard record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dashboard = await Dashboard.prisma().upsert(
            where={
                'id': 1440265249,
            },
            data={
                'create': {
                    'id': 1440265249,
                    'title': 'bfhdjaiejf',
                    'slug': 'bbjfijjadg',
                },
                'update': {
                    'title': 'bfhdjaiejf',
                    'slug': 'bbjfijjadg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DashboardUpdateManyMutationInput,
        where: types.DashboardWhereInput,
    ) -> int:
        """Update multiple Dashboard records

        Parameters
        ----------
        data
            Dashboard data to update the selected Dashboard records to
        where
            Filter to select the Dashboard records to update

        Returns
        -------
        int
            The total number of Dashboard records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Dashboard records
        total = await Dashboard.prisma().update_many(
            data={
                'deletedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DashboardWhereInput] = None,
        cursor: Optional[types.DashboardWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Dashboard records present in the database

        Parameters
        ----------
        select
            Select the Dashboard fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Dashboard filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DashboardCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Dashboard.prisma().count()

        # results: prisma.types.DashboardCountAggregateOutput
        results = await Dashboard.prisma().count(
            select={
                '_all': True,
                'organizationId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DashboardCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DashboardWhereInput] = None,
        cursor: Optional[types.DashboardWhereUniqueInput] = None,
    ) -> types.DashboardCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DashboardCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DashboardWhereInput] = None,
        cursor: Optional[types.DashboardWhereUniqueInput] = None,
    ) -> Union[int, types.DashboardCountAggregateOutput]:
        """Count the number of Dashboard records present in the database

        Parameters
        ----------
        select
            Select the Dashboard fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Dashboard filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DashboardCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Dashboard.prisma().count()

        # results: prisma.types.DashboardCountAggregateOutput
        results = await Dashboard.prisma().count(
            select={
                '_all': True,
                'ownerId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DashboardCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DashboardWhereInput] = None
    ) -> int:
        """Delete multiple Dashboard records.

        Parameters
        ----------
        where
            Optional Dashboard filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Dashboard records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Dashboard records
        total = await Dashboard.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DashboardScalarFieldKeys'],
        *,
        where: Optional['types.DashboardWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DashboardAvgAggregateInput'] = None,
        sum: Optional['types.DashboardSumAggregateInput'] = None,
        min: Optional['types.DashboardMinAggregateInput'] = None,
        max: Optional['types.DashboardMaxAggregateInput'] = None,
        having: Optional['types.DashboardScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DashboardCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DashboardScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DashboardScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DashboardGroupByOutput']:
        """Group Dashboard records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Dashboard fields to group records by
        where
            Dashboard filter to select records
        take
            Limit the maximum number of Dashboard records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DashboardGroupByOutput]
            A list of dictionaries representing the Dashboard record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Dashboard records by slug values
        # and count how many records are in each group
        results = await Dashboard.prisma().group_by(
            ['slug'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DashboardDatasetActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.DashboardDataset]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await DashboardDataset.prisma().query_raw(
            'SELECT * FROM DashboardDataset WHERE id = $1',
            1185738822,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.DashboardDataset
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await DashboardDataset.prisma().query_first(
            'SELECT * FROM DashboardDataset WHERE dashboardId = $1',
            1694224903,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DashboardDatasetCreateInput,
        include: Optional[types.DashboardDatasetInclude] = None
    ) -> _PrismaModelT:
        """Create a new DashboardDataset record.

        Parameters
        ----------
        data
            DashboardDataset record data
        include
            Specifies which relations should be loaded on the returned DashboardDataset model

        Returns
        -------
        prisma.models.DashboardDataset
            The created DashboardDataset record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a DashboardDataset record from just the required fields
        dashboarddataset = await DashboardDataset.prisma().create(
            data={
                # data to create a DashboardDataset record
                'dashboardId': 1906360116,
                'datasetId': 1911255389,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DashboardDatasetCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple DashboardDataset records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of DashboardDataset record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await DashboardDataset.prisma().create_many(
            data=[
                {
                    # data to create a DashboardDataset record
                    'dashboardId': 146262738,
                    'datasetId': 1719240611,
                },
                {
                    # data to create a DashboardDataset record
                    'dashboardId': 1948555936,
                    'datasetId': 1383253593,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DashboardDatasetWhereUniqueInput,
        include: Optional[types.DashboardDatasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single DashboardDataset record.

        Parameters
        ----------
        where
            DashboardDataset filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned DashboardDataset model

        Returns
        -------
        prisma.models.DashboardDataset
            The deleted DashboardDataset record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dashboarddataset = await DashboardDataset.prisma().delete(
            where={
                'id': 354664990,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DashboardDatasetWhereUniqueInput,
        include: Optional[types.DashboardDatasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique DashboardDataset record.

        Parameters
        ----------
        where
            DashboardDataset filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DashboardDataset model

        Returns
        -------
        prisma.models.DashboardDataset
            The found DashboardDataset record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dashboarddataset = await DashboardDataset.prisma().find_unique(
            where={
                'id': 647166719,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DashboardDatasetWhereUniqueInput,
        include: Optional[types.DashboardDatasetInclude] = None
    ) -> _PrismaModelT:
        """Find a unique DashboardDataset record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            DashboardDataset filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DashboardDataset model

        Returns
        -------
        prisma.models.DashboardDataset
            The found DashboardDataset record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dashboarddataset = await DashboardDataset.prisma().find_unique_or_raise(
            where={
                'id': 357089484,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DashboardDatasetWhereInput] = None,
        cursor: Optional[types.DashboardDatasetWhereUniqueInput] = None,
        include: Optional[types.DashboardDatasetInclude] = None,
        order: Optional[Union[types.DashboardDatasetOrderByInput, List[types.DashboardDatasetOrderByInput]]] = None,
        distinct: Optional[List[types.DashboardDatasetScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple DashboardDataset records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of DashboardDataset records returned
        skip
            Ignore the first N results
        where
            DashboardDataset filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DashboardDataset model
        order
            Order the returned DashboardDataset records by any field
        distinct
            Filter DashboardDataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.DashboardDataset]
            The list of all DashboardDataset records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 DashboardDataset records
        dashboarddatasets = await DashboardDataset.prisma().find_many(take=10)

        # find the first 5 DashboardDataset records ordered by the datasetId field
        dashboarddatasets = await DashboardDataset.prisma().find_many(
            take=5,
            order={
                'datasetId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DashboardDatasetWhereInput] = None,
        cursor: Optional[types.DashboardDatasetWhereUniqueInput] = None,
        include: Optional[types.DashboardDatasetInclude] = None,
        order: Optional[Union[types.DashboardDatasetOrderByInput, List[types.DashboardDatasetOrderByInput]]] = None,
        distinct: Optional[List[types.DashboardDatasetScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single DashboardDataset record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DashboardDataset filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DashboardDataset model
        order
            Order the returned DashboardDataset records by any field
        distinct
            Filter DashboardDataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DashboardDataset
            The first DashboardDataset record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DashboardDataset record ordered by the addedAt field
        dashboarddataset = await DashboardDataset.prisma().find_first(
            skip=1,
            order={
                'addedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DashboardDatasetWhereInput] = None,
        cursor: Optional[types.DashboardDatasetWhereUniqueInput] = None,
        include: Optional[types.DashboardDatasetInclude] = None,
        order: Optional[Union[types.DashboardDatasetOrderByInput, List[types.DashboardDatasetOrderByInput]]] = None,
        distinct: Optional[List[types.DashboardDatasetScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single DashboardDataset record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DashboardDataset filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DashboardDataset model
        order
            Order the returned DashboardDataset records by any field
        distinct
            Filter DashboardDataset records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DashboardDataset
            The first DashboardDataset record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DashboardDataset record ordered by the id field
        dashboarddataset = await DashboardDataset.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DashboardDatasetUpdateInput,
        where: types.DashboardDatasetWhereUniqueInput,
        include: Optional[types.DashboardDatasetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single DashboardDataset record.

        Parameters
        ----------
        data
            DashboardDataset record data specifying what to update
        where
            DashboardDataset filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned DashboardDataset model

        Returns
        -------
        prisma.models.DashboardDataset
            The updated DashboardDataset record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        dashboarddataset = await DashboardDataset.prisma().update(
            where={
                'id': 612396821,
            },
            data={
                # data to update the DashboardDataset record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DashboardDatasetWhereUniqueInput,
        data: types.DashboardDatasetUpsertInput,
        include: Optional[types.DashboardDatasetInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            DashboardDataset filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned DashboardDataset model

        Returns
        -------
        prisma.models.DashboardDataset
            The created or updated DashboardDataset record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        dashboarddataset = await DashboardDataset.prisma().upsert(
            where={
                'id': 1808130602,
            },
            data={
                'create': {
                    'id': 1808130602,
                    'dashboardId': 1948555936,
                    'datasetId': 1383253593,
                },
                'update': {
                    'dashboardId': 1948555936,
                    'datasetId': 1383253593,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DashboardDatasetUpdateManyMutationInput,
        where: types.DashboardDatasetWhereInput,
    ) -> int:
        """Update multiple DashboardDataset records

        Parameters
        ----------
        data
            DashboardDataset data to update the selected DashboardDataset records to
        where
            Filter to select the DashboardDataset records to update

        Returns
        -------
        int
            The total number of DashboardDataset records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all DashboardDataset records
        total = await DashboardDataset.prisma().update_many(
            data={
                'dashboardId': 1151748123
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DashboardDatasetWhereInput] = None,
        cursor: Optional[types.DashboardDatasetWhereUniqueInput] = None,
    ) -> int:
        """Count the number of DashboardDataset records present in the database

        Parameters
        ----------
        select
            Select the DashboardDataset fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DashboardDataset filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DashboardDatasetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DashboardDataset.prisma().count()

        # results: prisma.types.DashboardDatasetCountAggregateOutput
        results = await DashboardDataset.prisma().count(
            select={
                '_all': True,
                'datasetId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DashboardDatasetCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DashboardDatasetWhereInput] = None,
        cursor: Optional[types.DashboardDatasetWhereUniqueInput] = None,
    ) -> types.DashboardDatasetCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DashboardDatasetCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DashboardDatasetWhereInput] = None,
        cursor: Optional[types.DashboardDatasetWhereUniqueInput] = None,
    ) -> Union[int, types.DashboardDatasetCountAggregateOutput]:
        """Count the number of DashboardDataset records present in the database

        Parameters
        ----------
        select
            Select the DashboardDataset fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DashboardDataset filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DashboardDatasetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DashboardDataset.prisma().count()

        # results: prisma.types.DashboardDatasetCountAggregateOutput
        results = await DashboardDataset.prisma().count(
            select={
                '_all': True,
                'addedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DashboardDatasetCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DashboardDatasetWhereInput] = None
    ) -> int:
        """Delete multiple DashboardDataset records.

        Parameters
        ----------
        where
            Optional DashboardDataset filter to find the records to be deleted

        Returns
        -------
        int
            The total number of DashboardDataset records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all DashboardDataset records
        total = await DashboardDataset.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DashboardDatasetScalarFieldKeys'],
        *,
        where: Optional['types.DashboardDatasetWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DashboardDatasetAvgAggregateInput'] = None,
        sum: Optional['types.DashboardDatasetSumAggregateInput'] = None,
        min: Optional['types.DashboardDatasetMinAggregateInput'] = None,
        max: Optional['types.DashboardDatasetMaxAggregateInput'] = None,
        having: Optional['types.DashboardDatasetScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DashboardDatasetCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DashboardDatasetScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DashboardDatasetScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DashboardDatasetGroupByOutput']:
        """Group DashboardDataset records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar DashboardDataset fields to group records by
        where
            DashboardDataset filter to select records
        take
            Limit the maximum number of DashboardDataset records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DashboardDatasetGroupByOutput]
            A list of dictionaries representing the DashboardDataset record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group DashboardDataset records by id values
        # and count how many records are in each group
        results = await DashboardDataset.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WidgetActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Widget]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Widget.prisma().query_raw(
            'SELECT * FROM Widget WHERE id = $1',
            78060984,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Widget
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Widget.prisma().query_first(
            'SELECT * FROM Widget WHERE dashboardId = $1',
            444983185,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WidgetCreateInput,
        include: Optional[types.WidgetInclude] = None
    ) -> _PrismaModelT:
        """Create a new Widget record.

        Parameters
        ----------
        data
            Widget record data
        include
            Specifies which relations should be loaded on the returned Widget model

        Returns
        -------
        prisma.models.Widget
            The created Widget record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Widget record from just the required fields
        widget = await Widget.prisma().create(
            data={
                # data to create a Widget record
                'type': enums.WidgetType.CHART,
                'config': Json({'efgbahec': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WidgetCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Widget records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Widget record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Widget.prisma().create_many(
            data=[
                {
                    # data to create a Widget record
                    'type': enums.WidgetType.CHART,
                    'config': Json({'hgjaiebfb': True}),
                },
                {
                    # data to create a Widget record
                    'type': enums.WidgetType.CHART,
                    'config': Json({'bddefjjabc': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WidgetWhereUniqueInput,
        include: Optional[types.WidgetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Widget record.

        Parameters
        ----------
        where
            Widget filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Widget model

        Returns
        -------
        prisma.models.Widget
            The deleted Widget record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        widget = await Widget.prisma().delete(
            where={
                'id': 1116761037,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WidgetWhereUniqueInput,
        include: Optional[types.WidgetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Widget record.

        Parameters
        ----------
        where
            Widget filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Widget model

        Returns
        -------
        prisma.models.Widget
            The found Widget record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        widget = await Widget.prisma().find_unique(
            where={
                'id': 1172606082,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WidgetWhereUniqueInput,
        include: Optional[types.WidgetInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Widget record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Widget filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Widget model

        Returns
        -------
        prisma.models.Widget
            The found Widget record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        widget = await Widget.prisma().find_unique_or_raise(
            where={
                'id': 330014611,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WidgetWhereInput] = None,
        cursor: Optional[types.WidgetWhereUniqueInput] = None,
        include: Optional[types.WidgetInclude] = None,
        order: Optional[Union[types.WidgetOrderByInput, List[types.WidgetOrderByInput]]] = None,
        distinct: Optional[List[types.WidgetScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Widget records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Widget records returned
        skip
            Ignore the first N results
        where
            Widget filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Widget model
        order
            Order the returned Widget records by any field
        distinct
            Filter Widget records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Widget]
            The list of all Widget records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Widget records
        widgets = await Widget.prisma().find_many(take=10)

        # find the first 5 Widget records ordered by the datasetId field
        widgets = await Widget.prisma().find_many(
            take=5,
            order={
                'datasetId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WidgetWhereInput] = None,
        cursor: Optional[types.WidgetWhereUniqueInput] = None,
        include: Optional[types.WidgetInclude] = None,
        order: Optional[Union[types.WidgetOrderByInput, List[types.WidgetOrderByInput]]] = None,
        distinct: Optional[List[types.WidgetScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Widget record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Widget filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Widget model
        order
            Order the returned Widget records by any field
        distinct
            Filter Widget records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Widget
            The first Widget record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Widget record ordered by the type field
        widget = await Widget.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WidgetWhereInput] = None,
        cursor: Optional[types.WidgetWhereUniqueInput] = None,
        include: Optional[types.WidgetInclude] = None,
        order: Optional[Union[types.WidgetOrderByInput, List[types.WidgetOrderByInput]]] = None,
        distinct: Optional[List[types.WidgetScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Widget record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Widget filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Widget model
        order
            Order the returned Widget records by any field
        distinct
            Filter Widget records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Widget
            The first Widget record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Widget record ordered by the config field
        widget = await Widget.prisma().find_first_or_raise(
            skip=1,
            order={
                'config': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WidgetUpdateInput,
        where: types.WidgetWhereUniqueInput,
        include: Optional[types.WidgetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Widget record.

        Parameters
        ----------
        data
            Widget record data specifying what to update
        where
            Widget filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Widget model

        Returns
        -------
        prisma.models.Widget
            The updated Widget record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        widget = await Widget.prisma().update(
            where={
                'id': 1768156112,
            },
            data={
                # data to update the Widget record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WidgetWhereUniqueInput,
        data: types.WidgetUpsertInput,
        include: Optional[types.WidgetInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Widget filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Widget model

        Returns
        -------
        prisma.models.Widget
            The created or updated Widget record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        widget = await Widget.prisma().upsert(
            where={
                'id': 71628745,
            },
            data={
                'create': {
                    'id': 71628745,
                    'type': enums.WidgetType.CHART,
                    'config': Json({'bddefjjabc': True}),
                },
                'update': {
                    'type': enums.WidgetType.CHART,
                    'config': Json({'bddefjjabc': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WidgetUpdateManyMutationInput,
        where: types.WidgetWhereInput,
    ) -> int:
        """Update multiple Widget records

        Parameters
        ----------
        data
            Widget data to update the selected Widget records to
        where
            Filter to select the Widget records to update

        Returns
        -------
        int
            The total number of Widget records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Widget records
        total = await Widget.prisma().update_many(
            data={
                'order': 55766734
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WidgetWhereInput] = None,
        cursor: Optional[types.WidgetWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Widget records present in the database

        Parameters
        ----------
        select
            Select the Widget fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Widget filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WidgetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Widget.prisma().count()

        # results: prisma.types.WidgetCountAggregateOutput
        results = await Widget.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WidgetCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WidgetWhereInput] = None,
        cursor: Optional[types.WidgetWhereUniqueInput] = None,
    ) -> types.WidgetCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WidgetCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WidgetWhereInput] = None,
        cursor: Optional[types.WidgetWhereUniqueInput] = None,
    ) -> Union[int, types.WidgetCountAggregateOutput]:
        """Count the number of Widget records present in the database

        Parameters
        ----------
        select
            Select the Widget fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Widget filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WidgetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Widget.prisma().count()

        # results: prisma.types.WidgetCountAggregateOutput
        results = await Widget.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WidgetCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WidgetWhereInput] = None
    ) -> int:
        """Delete multiple Widget records.

        Parameters
        ----------
        where
            Optional Widget filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Widget records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Widget records
        total = await Widget.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WidgetScalarFieldKeys'],
        *,
        where: Optional['types.WidgetWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WidgetAvgAggregateInput'] = None,
        sum: Optional['types.WidgetSumAggregateInput'] = None,
        min: Optional['types.WidgetMinAggregateInput'] = None,
        max: Optional['types.WidgetMaxAggregateInput'] = None,
        having: Optional['types.WidgetScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WidgetCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WidgetScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WidgetScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WidgetGroupByOutput']:
        """Group Widget records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Widget fields to group records by
        where
            Widget filter to select records
        take
            Limit the maximum number of Widget records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WidgetGroupByOutput]
            A list of dictionaries representing the Widget record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Widget records by deletedAt values
        # and count how many records are in each group
        results = await Widget.prisma().group_by(
            ['deletedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InsightActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Insight]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Insight.prisma().query_raw(
            'SELECT * FROM Insight WHERE id = $1',
            812032495,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Insight
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Insight.prisma().query_first(
            'SELECT * FROM Insight WHERE dashboardId = $1',
            1323562236,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InsightCreateInput,
        include: Optional[types.InsightInclude] = None
    ) -> _PrismaModelT:
        """Create a new Insight record.

        Parameters
        ----------
        data
            Insight record data
        include
            Specifies which relations should be loaded on the returned Insight model

        Returns
        -------
        prisma.models.Insight
            The created Insight record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Insight record from just the required fields
        insight = await Insight.prisma().create(
            data={
                # data to create a Insight record
                'dashboardId': 43796357,
                'content': 'bdeffdadda',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InsightCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Insight records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Insight record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Insight.prisma().create_many(
            data=[
                {
                    # data to create a Insight record
                    'dashboardId': 1965387275,
                    'content': 'iaeihdeei',
                },
                {
                    # data to create a Insight record
                    'dashboardId': 1566496513,
                    'content': 'ifaaaedja',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InsightWhereUniqueInput,
        include: Optional[types.InsightInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Insight record.

        Parameters
        ----------
        where
            Insight filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Insight model

        Returns
        -------
        prisma.models.Insight
            The deleted Insight record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        insight = await Insight.prisma().delete(
            where={
                'id': 2109399015,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InsightWhereUniqueInput,
        include: Optional[types.InsightInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Insight record.

        Parameters
        ----------
        where
            Insight filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Insight model

        Returns
        -------
        prisma.models.Insight
            The found Insight record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        insight = await Insight.prisma().find_unique(
            where={
                'id': 1282664340,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InsightWhereUniqueInput,
        include: Optional[types.InsightInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Insight record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Insight filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Insight model

        Returns
        -------
        prisma.models.Insight
            The found Insight record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        insight = await Insight.prisma().find_unique_or_raise(
            where={
                'id': 241230397,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InsightWhereInput] = None,
        cursor: Optional[types.InsightWhereUniqueInput] = None,
        include: Optional[types.InsightInclude] = None,
        order: Optional[Union[types.InsightOrderByInput, List[types.InsightOrderByInput]]] = None,
        distinct: Optional[List[types.InsightScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Insight records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Insight records returned
        skip
            Ignore the first N results
        where
            Insight filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Insight model
        order
            Order the returned Insight records by any field
        distinct
            Filter Insight records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Insight]
            The list of all Insight records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Insight records
        insights = await Insight.prisma().find_many(take=10)

        # find the first 5 Insight records ordered by the userId field
        insights = await Insight.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InsightWhereInput] = None,
        cursor: Optional[types.InsightWhereUniqueInput] = None,
        include: Optional[types.InsightInclude] = None,
        order: Optional[Union[types.InsightOrderByInput, List[types.InsightOrderByInput]]] = None,
        distinct: Optional[List[types.InsightScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Insight record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Insight filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Insight model
        order
            Order the returned Insight records by any field
        distinct
            Filter Insight records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Insight
            The first Insight record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Insight record ordered by the content field
        insight = await Insight.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InsightWhereInput] = None,
        cursor: Optional[types.InsightWhereUniqueInput] = None,
        include: Optional[types.InsightInclude] = None,
        order: Optional[Union[types.InsightOrderByInput, List[types.InsightOrderByInput]]] = None,
        distinct: Optional[List[types.InsightScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Insight record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Insight filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Insight model
        order
            Order the returned Insight records by any field
        distinct
            Filter Insight records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Insight
            The first Insight record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Insight record ordered by the metadata field
        insight = await Insight.prisma().find_first_or_raise(
            skip=1,
            order={
                'metadata': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InsightUpdateInput,
        where: types.InsightWhereUniqueInput,
        include: Optional[types.InsightInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Insight record.

        Parameters
        ----------
        data
            Insight record data specifying what to update
        where
            Insight filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Insight model

        Returns
        -------
        prisma.models.Insight
            The updated Insight record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        insight = await Insight.prisma().update(
            where={
                'id': 475863602,
            },
            data={
                # data to update the Insight record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InsightWhereUniqueInput,
        data: types.InsightUpsertInput,
        include: Optional[types.InsightInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Insight filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Insight model

        Returns
        -------
        prisma.models.Insight
            The created or updated Insight record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        insight = await Insight.prisma().upsert(
            where={
                'id': 1716228995,
            },
            data={
                'create': {
                    'id': 1716228995,
                    'dashboardId': 1566496513,
                    'content': 'ifaaaedja',
                },
                'update': {
                    'dashboardId': 1566496513,
                    'content': 'ifaaaedja',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InsightUpdateManyMutationInput,
        where: types.InsightWhereInput,
    ) -> int:
        """Update multiple Insight records

        Parameters
        ----------
        data
            Insight data to update the selected Insight records to
        where
            Filter to select the Insight records to update

        Returns
        -------
        int
            The total number of Insight records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Insight records
        total = await Insight.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InsightWhereInput] = None,
        cursor: Optional[types.InsightWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Insight records present in the database

        Parameters
        ----------
        select
            Select the Insight fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Insight filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InsightCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Insight.prisma().count()

        # results: prisma.types.InsightCountAggregateOutput
        results = await Insight.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InsightCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InsightWhereInput] = None,
        cursor: Optional[types.InsightWhereUniqueInput] = None,
    ) -> types.InsightCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InsightCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InsightWhereInput] = None,
        cursor: Optional[types.InsightWhereUniqueInput] = None,
    ) -> Union[int, types.InsightCountAggregateOutput]:
        """Count the number of Insight records present in the database

        Parameters
        ----------
        select
            Select the Insight fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Insight filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InsightCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Insight.prisma().count()

        # results: prisma.types.InsightCountAggregateOutput
        results = await Insight.prisma().count(
            select={
                '_all': True,
                'deletedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InsightCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InsightWhereInput] = None
    ) -> int:
        """Delete multiple Insight records.

        Parameters
        ----------
        where
            Optional Insight filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Insight records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Insight records
        total = await Insight.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InsightScalarFieldKeys'],
        *,
        where: Optional['types.InsightWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InsightAvgAggregateInput'] = None,
        sum: Optional['types.InsightSumAggregateInput'] = None,
        min: Optional['types.InsightMinAggregateInput'] = None,
        max: Optional['types.InsightMaxAggregateInput'] = None,
        having: Optional['types.InsightScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InsightCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InsightScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InsightScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InsightGroupByOutput']:
        """Group Insight records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Insight fields to group records by
        where
            Insight filter to select records
        take
            Limit the maximum number of Insight records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InsightGroupByOutput]
            A list of dictionaries representing the Insight record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Insight records by id values
        # and count how many records are in each group
        results = await Insight.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MLModelActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.MLModel]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await MLModel.prisma().query_raw(
            'SELECT * FROM MLModel WHERE id = $1',
            1869736192,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.MLModel
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await MLModel.prisma().query_first(
            'SELECT * FROM MLModel WHERE datasetId = $1',
            1585341753,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MLModelCreateInput,
        include: Optional[types.MLModelInclude] = None
    ) -> _PrismaModelT:
        """Create a new MLModel record.

        Parameters
        ----------
        data
            MLModel record data
        include
            Specifies which relations should be loaded on the returned MLModel model

        Returns
        -------
        prisma.models.MLModel
            The created MLModel record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MLModel record from just the required fields
        mlmodel = await MLModel.prisma().create(
            data={
                # data to create a MLModel record
                'datasetId': 29271934,
                'name': 'bfiibjcehj',
                'type': 'ijieafghg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MLModelCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MLModel records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MLModel record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MLModel.prisma().create_many(
            data=[
                {
                    # data to create a MLModel record
                    'datasetId': 777460725,
                    'name': 'edhijefdi',
                    'type': 'djddecjhb',
                },
                {
                    # data to create a MLModel record
                    'datasetId': 163829784,
                    'name': 'ceibfcgij',
                    'type': 'debhbfada',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MLModelWhereUniqueInput,
        include: Optional[types.MLModelInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MLModel record.

        Parameters
        ----------
        where
            MLModel filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MLModel model

        Returns
        -------
        prisma.models.MLModel
            The deleted MLModel record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mlmodel = await MLModel.prisma().delete(
            where={
                'id': 1692766423,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MLModelWhereUniqueInput,
        include: Optional[types.MLModelInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MLModel record.

        Parameters
        ----------
        where
            MLModel filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MLModel model

        Returns
        -------
        prisma.models.MLModel
            The found MLModel record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mlmodel = await MLModel.prisma().find_unique(
            where={
                'id': 86662596,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MLModelWhereUniqueInput,
        include: Optional[types.MLModelInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MLModel record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MLModel filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MLModel model

        Returns
        -------
        prisma.models.MLModel
            The found MLModel record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mlmodel = await MLModel.prisma().find_unique_or_raise(
            where={
                'id': 1697895597,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MLModelWhereInput] = None,
        cursor: Optional[types.MLModelWhereUniqueInput] = None,
        include: Optional[types.MLModelInclude] = None,
        order: Optional[Union[types.MLModelOrderByInput, List[types.MLModelOrderByInput]]] = None,
        distinct: Optional[List[types.MLModelScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MLModel records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MLModel records returned
        skip
            Ignore the first N results
        where
            MLModel filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MLModel model
        order
            Order the returned MLModel records by any field
        distinct
            Filter MLModel records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MLModel]
            The list of all MLModel records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MLModel records
        mlmodels = await MLModel.prisma().find_many(take=10)

        # find the first 5 MLModel records ordered by the creatorId field
        mlmodels = await MLModel.prisma().find_many(
            take=5,
            order={
                'creatorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MLModelWhereInput] = None,
        cursor: Optional[types.MLModelWhereUniqueInput] = None,
        include: Optional[types.MLModelInclude] = None,
        order: Optional[Union[types.MLModelOrderByInput, List[types.MLModelOrderByInput]]] = None,
        distinct: Optional[List[types.MLModelScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MLModel record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MLModel filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MLModel model
        order
            Order the returned MLModel records by any field
        distinct
            Filter MLModel records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MLModel
            The first MLModel record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MLModel record ordered by the name field
        mlmodel = await MLModel.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MLModelWhereInput] = None,
        cursor: Optional[types.MLModelWhereUniqueInput] = None,
        include: Optional[types.MLModelInclude] = None,
        order: Optional[Union[types.MLModelOrderByInput, List[types.MLModelOrderByInput]]] = None,
        distinct: Optional[List[types.MLModelScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MLModel record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MLModel filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MLModel model
        order
            Order the returned MLModel records by any field
        distinct
            Filter MLModel records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MLModel
            The first MLModel record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MLModel record ordered by the type field
        mlmodel = await MLModel.prisma().find_first_or_raise(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MLModelUpdateInput,
        where: types.MLModelWhereUniqueInput,
        include: Optional[types.MLModelInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MLModel record.

        Parameters
        ----------
        data
            MLModel record data specifying what to update
        where
            MLModel filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MLModel model

        Returns
        -------
        prisma.models.MLModel
            The updated MLModel record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        mlmodel = await MLModel.prisma().update(
            where={
                'id': 1286370274,
            },
            data={
                # data to update the MLModel record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MLModelWhereUniqueInput,
        data: types.MLModelUpsertInput,
        include: Optional[types.MLModelInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MLModel filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MLModel model

        Returns
        -------
        prisma.models.MLModel
            The created or updated MLModel record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mlmodel = await MLModel.prisma().upsert(
            where={
                'id': 864576371,
            },
            data={
                'create': {
                    'id': 864576371,
                    'datasetId': 163829784,
                    'name': 'ceibfcgij',
                    'type': 'debhbfada',
                },
                'update': {
                    'datasetId': 163829784,
                    'name': 'ceibfcgij',
                    'type': 'debhbfada',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MLModelUpdateManyMutationInput,
        where: types.MLModelWhereInput,
    ) -> int:
        """Update multiple MLModel records

        Parameters
        ----------
        data
            MLModel data to update the selected MLModel records to
        where
            Filter to select the MLModel records to update

        Returns
        -------
        int
            The total number of MLModel records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MLModel records
        total = await MLModel.prisma().update_many(
            data={
                'modelPath': 'ejbiifbae'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MLModelWhereInput] = None,
        cursor: Optional[types.MLModelWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MLModel records present in the database

        Parameters
        ----------
        select
            Select the MLModel fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MLModel filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MLModelCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MLModel.prisma().count()

        # results: prisma.types.MLModelCountAggregateOutput
        results = await MLModel.prisma().count(
            select={
                '_all': True,
                'metrics': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MLModelCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MLModelWhereInput] = None,
        cursor: Optional[types.MLModelWhereUniqueInput] = None,
    ) -> types.MLModelCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MLModelCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MLModelWhereInput] = None,
        cursor: Optional[types.MLModelWhereUniqueInput] = None,
    ) -> Union[int, types.MLModelCountAggregateOutput]:
        """Count the number of MLModel records present in the database

        Parameters
        ----------
        select
            Select the MLModel fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MLModel filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MLModelCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MLModel.prisma().count()

        # results: prisma.types.MLModelCountAggregateOutput
        results = await MLModel.prisma().count(
            select={
                '_all': True,
                'params': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MLModelCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MLModelWhereInput] = None
    ) -> int:
        """Delete multiple MLModel records.

        Parameters
        ----------
        where
            Optional MLModel filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MLModel records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MLModel records
        total = await MLModel.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MLModelScalarFieldKeys'],
        *,
        where: Optional['types.MLModelWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MLModelAvgAggregateInput'] = None,
        sum: Optional['types.MLModelSumAggregateInput'] = None,
        min: Optional['types.MLModelMinAggregateInput'] = None,
        max: Optional['types.MLModelMaxAggregateInput'] = None,
        having: Optional['types.MLModelScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MLModelCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MLModelScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MLModelScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MLModelGroupByOutput']:
        """Group MLModel records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MLModel fields to group records by
        where
            MLModel filter to select records
        take
            Limit the maximum number of MLModel records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MLModelGroupByOutput]
            A list of dictionaries representing the MLModel record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MLModel records by createdAt values
        # and count how many records are in each group
        results = await MLModel.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TransactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Transaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Transaction.prisma().query_raw(
            'SELECT * FROM Transaction WHERE id = $1',
            392564393,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Transaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Transaction.prisma().query_first(
            'SELECT * FROM Transaction WHERE userId = $1',
            1319234606,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TransactionCreateInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Transaction record.

        Parameters
        ----------
        data
            Transaction record data
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created Transaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Transaction record from just the required fields
        transaction = await Transaction.prisma().create(
            data={
                # data to create a Transaction record
                'amountCents': 712754127,
                'type': 'bcjjffegfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TransactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Transaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Transaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Transaction.prisma().create_many(
            data=[
                {
                    # data to create a Transaction record
                    'amountCents': 2070408293,
                    'type': 'ibbjaacbi',
                },
                {
                    # data to create a Transaction record
                    'amountCents': 396021227,
                    'type': 'geeeegace',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Transaction record.

        Parameters
        ----------
        where
            Transaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The deleted Transaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().delete(
            where={
                'id': 116386273,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Transaction record.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique(
            where={
                'id': 309285638,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Transaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique_or_raise(
            where={
                'id': 22437319,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Transaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N results
        where
            Transaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Transaction]
            The list of all Transaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Transaction records
        transactions = await Transaction.prisma().find_many(take=10)

        # find the first 5 Transaction records ordered by the organizationId field
        transactions = await Transaction.prisma().find_many(
            take=5,
            order={
                'organizationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Transaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the amountCents field
        transaction = await Transaction.prisma().find_first(
            skip=1,
            order={
                'amountCents': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Transaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the currency field
        transaction = await Transaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'currency': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TransactionUpdateInput,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Transaction record.

        Parameters
        ----------
        data
            Transaction record data specifying what to update
        where
            Transaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The updated Transaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transaction = await Transaction.prisma().update(
            where={
                'id': 1900199924,
            },
            data={
                # data to update the Transaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TransactionWhereUniqueInput,
        data: types.TransactionUpsertInput,
        include: Optional[types.TransactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Transaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created or updated Transaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().upsert(
            where={
                'id': 2057323293,
            },
            data={
                'create': {
                    'id': 2057323293,
                    'amountCents': 396021227,
                    'type': 'geeeegace',
                },
                'update': {
                    'amountCents': 396021227,
                    'type': 'geeeegace',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TransactionUpdateManyMutationInput,
        where: types.TransactionWhereInput,
    ) -> int:
        """Update multiple Transaction records

        Parameters
        ----------
        data
            Transaction data to update the selected Transaction records to
        where
            Filter to select the Transaction records to update

        Returns
        -------
        int
            The total number of Transaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Transaction records
        total = await Transaction.prisma().update_many(
            data={
                'type': 'bdeebbhbdi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TransactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> types.TransactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TransactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> Union[int, types.TransactionCountAggregateOutput]:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'providerData': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TransactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TransactionWhereInput] = None
    ) -> int:
        """Delete multiple Transaction records.

        Parameters
        ----------
        where
            Optional Transaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Transaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Transaction records
        total = await Transaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TransactionScalarFieldKeys'],
        *,
        where: Optional['types.TransactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TransactionAvgAggregateInput'] = None,
        sum: Optional['types.TransactionSumAggregateInput'] = None,
        min: Optional['types.TransactionMinAggregateInput'] = None,
        max: Optional['types.TransactionMaxAggregateInput'] = None,
        having: Optional['types.TransactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TransactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TransactionGroupByOutput']:
        """Group Transaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Transaction fields to group records by
        where
            Transaction filter to select records
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TransactionGroupByOutput]
            A list of dictionaries representing the Transaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Transaction records by createdAt values
        # and count how many records are in each group
        results = await Transaction.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SubscriptionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Subscription]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Subscription.prisma().query_raw(
            'SELECT * FROM Subscription WHERE id = $1',
            2052132707,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Subscription
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Subscription.prisma().query_first(
            'SELECT * FROM Subscription WHERE userId = $1',
            1355147104,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SubscriptionCreateInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Subscription record.

        Parameters
        ----------
        data
            Subscription record data
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The created Subscription record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Subscription record from just the required fields
        subscription = await Subscription.prisma().create(
            data={
                # data to create a Subscription record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SubscriptionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Subscription records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Subscription record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Subscription.prisma().create_many(
            data=[
                {
                    # data to create a Subscription record
                },
                {
                    # data to create a Subscription record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SubscriptionWhereUniqueInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Subscription record.

        Parameters
        ----------
        where
            Subscription filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The deleted Subscription record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscription = await Subscription.prisma().delete(
            where={
                'id': 84079641,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SubscriptionWhereUniqueInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Subscription record.

        Parameters
        ----------
        where
            Subscription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The found Subscription record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscription = await Subscription.prisma().find_unique(
            where={
                'id': 754433246,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SubscriptionWhereUniqueInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Subscription record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Subscription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The found Subscription record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscription = await Subscription.prisma().find_unique_or_raise(
            where={
                'id': 314261183,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
        include: Optional[types.SubscriptionInclude] = None,
        order: Optional[Union[types.SubscriptionOrderByInput, List[types.SubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Subscription records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Subscription records returned
        skip
            Ignore the first N results
        where
            Subscription filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Subscription model
        order
            Order the returned Subscription records by any field
        distinct
            Filter Subscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Subscription]
            The list of all Subscription records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Subscription records
        subscriptions = await Subscription.prisma().find_many(take=10)

        # find the first 5 Subscription records ordered by the organizationId field
        subscriptions = await Subscription.prisma().find_many(
            take=5,
            order={
                'organizationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
        include: Optional[types.SubscriptionInclude] = None,
        order: Optional[Union[types.SubscriptionOrderByInput, List[types.SubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Subscription record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Subscription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Subscription model
        order
            Order the returned Subscription records by any field
        distinct
            Filter Subscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Subscription
            The first Subscription record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Subscription record ordered by the plan field
        subscription = await Subscription.prisma().find_first(
            skip=1,
            order={
                'plan': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
        include: Optional[types.SubscriptionInclude] = None,
        order: Optional[Union[types.SubscriptionOrderByInput, List[types.SubscriptionOrderByInput]]] = None,
        distinct: Optional[List[types.SubscriptionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Subscription record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Subscription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Subscription model
        order
            Order the returned Subscription records by any field
        distinct
            Filter Subscription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Subscription
            The first Subscription record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Subscription record ordered by the active field
        subscription = await Subscription.prisma().find_first_or_raise(
            skip=1,
            order={
                'active': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SubscriptionUpdateInput,
        where: types.SubscriptionWhereUniqueInput,
        include: Optional[types.SubscriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Subscription record.

        Parameters
        ----------
        data
            Subscription record data specifying what to update
        where
            Subscription filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The updated Subscription record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        subscription = await Subscription.prisma().update(
            where={
                'id': 227678604,
            },
            data={
                # data to update the Subscription record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SubscriptionWhereUniqueInput,
        data: types.SubscriptionUpsertInput,
        include: Optional[types.SubscriptionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Subscription filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Subscription model

        Returns
        -------
        prisma.models.Subscription
            The created or updated Subscription record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subscription = await Subscription.prisma().upsert(
            where={
                'id': 423999701,
            },
            data={
                'create': {
                    'id': 423999701,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SubscriptionUpdateManyMutationInput,
        where: types.SubscriptionWhereInput,
    ) -> int:
        """Update multiple Subscription records

        Parameters
        ----------
        data
            Subscription data to update the selected Subscription records to
        where
            Filter to select the Subscription records to update

        Returns
        -------
        int
            The total number of Subscription records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Subscription records
        total = await Subscription.prisma().update_many(
            data={
                'startedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Subscription records present in the database

        Parameters
        ----------
        select
            Select the Subscription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Subscription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubscriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Subscription.prisma().count()

        # results: prisma.types.SubscriptionCountAggregateOutput
        results = await Subscription.prisma().count(
            select={
                '_all': True,
                'endsAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SubscriptionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
    ) -> types.SubscriptionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SubscriptionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubscriptionWhereInput] = None,
        cursor: Optional[types.SubscriptionWhereUniqueInput] = None,
    ) -> Union[int, types.SubscriptionCountAggregateOutput]:
        """Count the number of Subscription records present in the database

        Parameters
        ----------
        select
            Select the Subscription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Subscription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubscriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Subscription.prisma().count()

        # results: prisma.types.SubscriptionCountAggregateOutput
        results = await Subscription.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SubscriptionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SubscriptionWhereInput] = None
    ) -> int:
        """Delete multiple Subscription records.

        Parameters
        ----------
        where
            Optional Subscription filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Subscription records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Subscription records
        total = await Subscription.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SubscriptionScalarFieldKeys'],
        *,
        where: Optional['types.SubscriptionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SubscriptionAvgAggregateInput'] = None,
        sum: Optional['types.SubscriptionSumAggregateInput'] = None,
        min: Optional['types.SubscriptionMinAggregateInput'] = None,
        max: Optional['types.SubscriptionMaxAggregateInput'] = None,
        having: Optional['types.SubscriptionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SubscriptionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SubscriptionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SubscriptionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SubscriptionGroupByOutput']:
        """Group Subscription records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Subscription fields to group records by
        where
            Subscription filter to select records
        take
            Limit the maximum number of Subscription records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SubscriptionGroupByOutput]
            A list of dictionaries representing the Subscription record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Subscription records by createdAt values
        # and count how many records are in each group
        results = await Subscription.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            180275434,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE userId = $1',
            57608155,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'userId': 2030912120,
                'type': 'bjheigfcdd',
                'body': 'bjejigcdcg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'userId': 1858881207,
                    'type': 'dbjibjdaa',
                    'body': 'dgijbdiaf',
                },
                {
                    # data to create a Notification record
                    'userId': 146508610,
                    'type': 'bdjiafcgjb',
                    'body': 'bficecgcfg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 219944329,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 343611790,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 201807279,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the type field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the title field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the body field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'body': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 261422524,
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 52920645,
            },
            data={
                'create': {
                    'id': 52920645,
                    'userId': 146508610,
                    'type': 'bdjiafcgjb',
                    'body': 'bficecgcfg',
                },
                'update': {
                    'userId': 146508610,
                    'type': 'bdjiafcgjb',
                    'body': 'bficecgcfg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'data': Json({'bgdhaeacic': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'isRead': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'emailSent': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeys'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by emailSentAt values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['emailSentAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuthTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AuthToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AuthToken.prisma().query_raw(
            'SELECT * FROM AuthToken WHERE id = $1',
            2055052747,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AuthToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AuthToken.prisma().query_first(
            'SELECT * FROM AuthToken WHERE userId = $1',
            59914664,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuthTokenCreateInput,
        include: Optional[types.AuthTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new AuthToken record.

        Parameters
        ----------
        data
            AuthToken record data
        include
            Specifies which relations should be loaded on the returned AuthToken model

        Returns
        -------
        prisma.models.AuthToken
            The created AuthToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AuthToken record from just the required fields
        authtoken = await AuthToken.prisma().create(
            data={
                # data to create a AuthToken record
                'userId': 1388571841,
                'token': 'cdcaejhgg',
                'type': 'jbijgfbfj',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuthTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AuthToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AuthToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AuthToken.prisma().create_many(
            data=[
                {
                    # data to create a AuthToken record
                    'userId': 665143380,
                    'token': 'djjejdaj',
                    'type': 'bjabbfceji',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a AuthToken record
                    'userId': 1627519811,
                    'token': 'bajecchdjc',
                    'type': 'dfgacajif',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuthTokenWhereUniqueInput,
        include: Optional[types.AuthTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AuthToken record.

        Parameters
        ----------
        where
            AuthToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AuthToken model

        Returns
        -------
        prisma.models.AuthToken
            The deleted AuthToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken = await AuthToken.prisma().delete(
            where={
                'id': 1638335038,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuthTokenWhereUniqueInput,
        include: Optional[types.AuthTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AuthToken record.

        Parameters
        ----------
        where
            AuthToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuthToken model

        Returns
        -------
        prisma.models.AuthToken
            The found AuthToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken = await AuthToken.prisma().find_unique(
            where={
                'id': 1891567775,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuthTokenWhereUniqueInput,
        include: Optional[types.AuthTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AuthToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AuthToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuthToken model

        Returns
        -------
        prisma.models.AuthToken
            The found AuthToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken = await AuthToken.prisma().find_unique_or_raise(
            where={
                'id': 1072778732,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuthTokenWhereInput] = None,
        cursor: Optional[types.AuthTokenWhereUniqueInput] = None,
        include: Optional[types.AuthTokenInclude] = None,
        order: Optional[Union[types.AuthTokenOrderByInput, List[types.AuthTokenOrderByInput]]] = None,
        distinct: Optional[List[types.AuthTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AuthToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AuthToken records returned
        skip
            Ignore the first N results
        where
            AuthToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuthToken model
        order
            Order the returned AuthToken records by any field
        distinct
            Filter AuthToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AuthToken]
            The list of all AuthToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AuthToken records
        authtokens = await AuthToken.prisma().find_many(take=10)

        # find the first 5 AuthToken records ordered by the token field
        authtokens = await AuthToken.prisma().find_many(
            take=5,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuthTokenWhereInput] = None,
        cursor: Optional[types.AuthTokenWhereUniqueInput] = None,
        include: Optional[types.AuthTokenInclude] = None,
        order: Optional[Union[types.AuthTokenOrderByInput, List[types.AuthTokenOrderByInput]]] = None,
        distinct: Optional[List[types.AuthTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AuthToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuthToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuthToken model
        order
            Order the returned AuthToken records by any field
        distinct
            Filter AuthToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuthToken
            The first AuthToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuthToken record ordered by the type field
        authtoken = await AuthToken.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuthTokenWhereInput] = None,
        cursor: Optional[types.AuthTokenWhereUniqueInput] = None,
        include: Optional[types.AuthTokenInclude] = None,
        order: Optional[Union[types.AuthTokenOrderByInput, List[types.AuthTokenOrderByInput]]] = None,
        distinct: Optional[List[types.AuthTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AuthToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuthToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuthToken model
        order
            Order the returned AuthToken records by any field
        distinct
            Filter AuthToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuthToken
            The first AuthToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuthToken record ordered by the expiresAt field
        authtoken = await AuthToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuthTokenUpdateInput,
        where: types.AuthTokenWhereUniqueInput,
        include: Optional[types.AuthTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AuthToken record.

        Parameters
        ----------
        data
            AuthToken record data specifying what to update
        where
            AuthToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AuthToken model

        Returns
        -------
        prisma.models.AuthToken
            The updated AuthToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        authtoken = await AuthToken.prisma().update(
            where={
                'id': 1879328181,
            },
            data={
                # data to update the AuthToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuthTokenWhereUniqueInput,
        data: types.AuthTokenUpsertInput,
        include: Optional[types.AuthTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AuthToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AuthToken model

        Returns
        -------
        prisma.models.AuthToken
            The created or updated AuthToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken = await AuthToken.prisma().upsert(
            where={
                'id': 1577911370,
            },
            data={
                'create': {
                    'id': 1577911370,
                    'userId': 1627519811,
                    'token': 'bajecchdjc',
                    'type': 'dfgacajif',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 1627519811,
                    'token': 'bajecchdjc',
                    'type': 'dfgacajif',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuthTokenUpdateManyMutationInput,
        where: types.AuthTokenWhereInput,
    ) -> int:
        """Update multiple AuthToken records

        Parameters
        ----------
        data
            AuthToken data to update the selected AuthToken records to
        where
            Filter to select the AuthToken records to update

        Returns
        -------
        int
            The total number of AuthToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AuthToken records
        total = await AuthToken.prisma().update_many(
            data={
                'usedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuthTokenWhereInput] = None,
        cursor: Optional[types.AuthTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AuthToken records present in the database

        Parameters
        ----------
        select
            Select the AuthToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuthToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuthTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuthToken.prisma().count()

        # results: prisma.types.AuthTokenCountAggregateOutput
        results = await AuthToken.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuthTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuthTokenWhereInput] = None,
        cursor: Optional[types.AuthTokenWhereUniqueInput] = None,
    ) -> types.AuthTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuthTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuthTokenWhereInput] = None,
        cursor: Optional[types.AuthTokenWhereUniqueInput] = None,
    ) -> Union[int, types.AuthTokenCountAggregateOutput]:
        """Count the number of AuthToken records present in the database

        Parameters
        ----------
        select
            Select the AuthToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuthToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuthTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuthToken.prisma().count()

        # results: prisma.types.AuthTokenCountAggregateOutput
        results = await AuthToken.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuthTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuthTokenWhereInput] = None
    ) -> int:
        """Delete multiple AuthToken records.

        Parameters
        ----------
        where
            Optional AuthToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AuthToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AuthToken records
        total = await AuthToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuthTokenScalarFieldKeys'],
        *,
        where: Optional['types.AuthTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuthTokenAvgAggregateInput'] = None,
        sum: Optional['types.AuthTokenSumAggregateInput'] = None,
        min: Optional['types.AuthTokenMinAggregateInput'] = None,
        max: Optional['types.AuthTokenMaxAggregateInput'] = None,
        having: Optional['types.AuthTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuthTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuthTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AuthTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AuthTokenGroupByOutput']:
        """Group AuthToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AuthToken fields to group records by
        where
            AuthToken filter to select records
        take
            Limit the maximum number of AuthToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuthTokenGroupByOutput]
            A list of dictionaries representing the AuthToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AuthToken records by userId values
        # and count how many records are in each group
        results = await AuthToken.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.File]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await File.prisma().query_raw(
            'SELECT * FROM File WHERE id = $1',
            504729531,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.File
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await File.prisma().query_first(
            'SELECT * FROM File WHERE path = $1',
            'bbaiefbee',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FileCreateInput,
        include: Optional[types.FileInclude] = None
    ) -> _PrismaModelT:
        """Create a new File record.

        Parameters
        ----------
        data
            File record data
        include
            Specifies which relations should be loaded on the returned File model

        Returns
        -------
        prisma.models.File
            The created File record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a File record from just the required fields
        file = await File.prisma().create(
            data={
                # data to create a File record
                'path': 'bdaacgjbaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple File records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of File record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await File.prisma().create_many(
            data=[
                {
                    # data to create a File record
                    'path': 'biibaighec',
                },
                {
                    # data to create a File record
                    'path': 'baicdfeidj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FileWhereUniqueInput,
        include: Optional[types.FileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single File record.

        Parameters
        ----------
        where
            File filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned File model

        Returns
        -------
        prisma.models.File
            The deleted File record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        file = await File.prisma().delete(
            where={
                'id': 1456828036,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FileWhereUniqueInput,
        include: Optional[types.FileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique File record.

        Parameters
        ----------
        where
            File filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned File model

        Returns
        -------
        prisma.models.File
            The found File record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        file = await File.prisma().find_unique(
            where={
                'id': 2124707437,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FileWhereUniqueInput,
        include: Optional[types.FileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique File record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            File filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned File model

        Returns
        -------
        prisma.models.File
            The found File record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        file = await File.prisma().find_unique_or_raise(
            where={
                'id': 1298780834,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FileWhereInput] = None,
        cursor: Optional[types.FileWhereUniqueInput] = None,
        include: Optional[types.FileInclude] = None,
        order: Optional[Union[types.FileOrderByInput, List[types.FileOrderByInput]]] = None,
        distinct: Optional[List[types.FileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple File records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of File records returned
        skip
            Ignore the first N results
        where
            File filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned File model
        order
            Order the returned File records by any field
        distinct
            Filter File records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.File]
            The list of all File records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 File records
        files = await File.prisma().find_many(take=10)

        # find the first 5 File records ordered by the size field
        files = await File.prisma().find_many(
            take=5,
            order={
                'size': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FileWhereInput] = None,
        cursor: Optional[types.FileWhereUniqueInput] = None,
        include: Optional[types.FileInclude] = None,
        order: Optional[Union[types.FileOrderByInput, List[types.FileOrderByInput]]] = None,
        distinct: Optional[List[types.FileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single File record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            File filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned File model
        order
            Order the returned File records by any field
        distinct
            Filter File records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.File
            The first File record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second File record ordered by the mimeType field
        file = await File.prisma().find_first(
            skip=1,
            order={
                'mimeType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FileWhereInput] = None,
        cursor: Optional[types.FileWhereUniqueInput] = None,
        include: Optional[types.FileInclude] = None,
        order: Optional[Union[types.FileOrderByInput, List[types.FileOrderByInput]]] = None,
        distinct: Optional[List[types.FileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single File record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            File filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned File model
        order
            Order the returned File records by any field
        distinct
            Filter File records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.File
            The first File record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second File record ordered by the uploadedBy field
        file = await File.prisma().find_first_or_raise(
            skip=1,
            order={
                'uploadedBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FileUpdateInput,
        where: types.FileWhereUniqueInput,
        include: Optional[types.FileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single File record.

        Parameters
        ----------
        data
            File record data specifying what to update
        where
            File filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned File model

        Returns
        -------
        prisma.models.File
            The updated File record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        file = await File.prisma().update(
            where={
                'id': 1065892659,
            },
            data={
                # data to update the File record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FileWhereUniqueInput,
        data: types.FileUpsertInput,
        include: Optional[types.FileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            File filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned File model

        Returns
        -------
        prisma.models.File
            The created or updated File record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        file = await File.prisma().upsert(
            where={
                'id': 1266478832,
            },
            data={
                'create': {
                    'id': 1266478832,
                    'path': 'baicdfeidj',
                },
                'update': {
                    'path': 'baicdfeidj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FileUpdateManyMutationInput,
        where: types.FileWhereInput,
    ) -> int:
        """Update multiple File records

        Parameters
        ----------
        data
            File data to update the selected File records to
        where
            Filter to select the File records to update

        Returns
        -------
        int
            The total number of File records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all File records
        total = await File.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FileWhereInput] = None,
        cursor: Optional[types.FileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of File records present in the database

        Parameters
        ----------
        select
            Select the File fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            File filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await File.prisma().count()

        # results: prisma.types.FileCountAggregateOutput
        results = await File.prisma().count(
            select={
                '_all': True,
                'deletedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FileWhereInput] = None,
        cursor: Optional[types.FileWhereUniqueInput] = None,
    ) -> types.FileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FileWhereInput] = None,
        cursor: Optional[types.FileWhereUniqueInput] = None,
    ) -> Union[int, types.FileCountAggregateOutput]:
        """Count the number of File records present in the database

        Parameters
        ----------
        select
            Select the File fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            File filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await File.prisma().count()

        # results: prisma.types.FileCountAggregateOutput
        results = await File.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FileWhereInput] = None
    ) -> int:
        """Delete multiple File records.

        Parameters
        ----------
        where
            Optional File filter to find the records to be deleted

        Returns
        -------
        int
            The total number of File records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all File records
        total = await File.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FileScalarFieldKeys'],
        *,
        where: Optional['types.FileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FileAvgAggregateInput'] = None,
        sum: Optional['types.FileSumAggregateInput'] = None,
        min: Optional['types.FileMinAggregateInput'] = None,
        max: Optional['types.FileMaxAggregateInput'] = None,
        having: Optional['types.FileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FileScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FileScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FileGroupByOutput']:
        """Group File records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar File fields to group records by
        where
            File filter to select records
        take
            Limit the maximum number of File records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FileGroupByOutput]
            A list of dictionaries representing the File record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group File records by path values
        # and count how many records are in each group
        results = await File.prisma().group_by(
            ['path'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AuditLog.prisma().query_raw(
            'SELECT * FROM AuditLog WHERE id = $1',
            1923026025,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AuditLog.prisma().query_first(
            'SELECT * FROM AuditLog WHERE actorId = $1',
            95844078,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuditLogCreateInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AuditLog record from just the required fields
        auditlog = await AuditLog.prisma().create(
            data={
                # data to create a AuditLog record
                'action': 'bijfjbddfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a AuditLog record
                    'action': 'cdcdjdcee',
                },
                {
                    # data to create a AuditLog record
                    'action': 'bbbgjdbgcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The deleted AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().delete(
            where={
                'id': 1243026426,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique(
            where={
                'id': 21355947,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 831237128,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N results
        where
            AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AuditLog]
            The list of all AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AuditLog records
        auditlogs = await AuditLog.prisma().find_many(take=10)

        # find the first 5 AuditLog records ordered by the action field
        auditlogs = await AuditLog.prisma().find_many(
            take=5,
            order={
                'action': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the model field
        auditlog = await AuditLog.prisma().find_first(
            skip=1,
            order={
                'model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the recordId field
        auditlog = await AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'recordId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuditLogUpdateInput,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data specifying what to update
        where
            AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The updated AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().update(
            where={
                'id': 1024647073,
            },
            data={
                # data to update the AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuditLogWhereUniqueInput,
        data: types.AuditLogUpsertInput,
        include: Optional[types.AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created or updated AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().upsert(
            where={
                'id': 414348742,
            },
            data={
                'create': {
                    'id': 414348742,
                    'action': 'bbbgjdbgcb',
                },
                'update': {
                    'action': 'bbbgjdbgcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuditLogUpdateManyMutationInput,
        where: types.AuditLogWhereInput,
    ) -> int:
        """Update multiple AuditLog records

        Parameters
        ----------
        data
            AuditLog data to update the selected AuditLog records to
        where
            Filter to select the AuditLog records to update

        Returns
        -------
        int
            The total number of AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AuditLog records
        total = await AuditLog.prisma().update_many(
            data={
                'changes': Json({'bajagjdfbb': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> types.AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.AuditLogCountAggregateOutput]:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple AuditLog records.

        Parameters
        ----------
        where
            Optional AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AuditLog records
        total = await AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuditLogScalarFieldKeys'],
        *,
        where: Optional['types.AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.AuditLogSumAggregateInput'] = None,
        min: Optional['types.AuditLogMinAggregateInput'] = None,
        max: Optional['types.AuditLogMaxAggregateInput'] = None,
        having: Optional['types.AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AuditLogGroupByOutput']:
        """Group AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AuditLog fields to group records by
        where
            AuditLog filter to select records
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuditLogGroupByOutput]
            A list of dictionaries representing the AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AuditLog records by actorId values
        # and count how many records are in each group
        results = await AuditLog.prisma().group_by(
            ['actorId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models