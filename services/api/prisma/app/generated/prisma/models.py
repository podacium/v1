# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _int
    fullName: _str
    email: Optional[_str] = None
    emailVerified: _bool
    passwordHash: Optional[_str] = None
    provider: 'enums.AuthProvider'
    providerId: Optional[_str] = None
    phoneNumber: Optional[_str] = None
    phoneVerified: _bool
    role: 'enums.UserRole'
    acceptedTerms: _bool
    subscribeNewsletter: _bool
    isActive: _bool
    lastLoginAt: Optional[datetime.datetime] = None
    loginCount: _int
    profilePictureUrl: Optional[_str] = None
    bio: Optional[_str] = None
    country: Optional[_str] = None
    city: Optional[_str] = None
    socialLinks: Optional['fields.Json'] = None
    skills: List[_str]
    primaryOrganizationId: Optional[_int] = None
    primaryOrganization: Optional['models.Organization'] = None
    ownedOrganization: Optional['models.Organization'] = None
    memberships: Optional[List['models.OrganizationMember']] = None
    sentInvites: Optional[List['models.OrganizationMember']] = None
    enrollments: Optional[List['models.Enrollment']] = None
    lessonProgresses: Optional[List['models.LessonProgress']] = None
    certificates: Optional[List['models.Certificate']] = None
    instructedModules: Optional[List['models.Module']] = None
    projects: Optional[List['models.Project']] = None
    proposals: Optional[List['models.Proposal']] = None
    contractsAsFreelancer: Optional[List['models.Contract']] = None
    contractsAsClient: Optional[List['models.Contract']] = None
    datasets: Optional[List['models.Dataset']] = None
    dashboards: Optional[List['models.Dashboard']] = None
    insights: Optional[List['models.Insight']] = None
    mlModels: Optional[List['models.MLModel']] = None
    transactions: Optional[List['models.Transaction']] = None
    subscriptions: Optional[List['models.Subscription']] = None
    notifications: Optional[List['models.Notification']] = None
    files: Optional[List['models.File']] = None
    authTokens: Optional[List['models.AuthToken']] = None
    auditLogs: Optional[List['models.AuditLog']] = None
    skillsDetails: Optional[List['models.UserSkill']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('skills', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Organization(bases.BaseOrganization):
    """Represents a Organization record"""

    id: _int
    name: _str
    slug: _str
    description: Optional[_str] = None
    country: Optional[_str] = None
    website: Optional[_str] = None
    industry: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    ownerId: Optional[_int] = None
    owner: Optional['models.User'] = None
    primaryUsers: Optional[List['models.User']] = None
    members: Optional[List['models.OrganizationMember']] = None
    datasets: Optional[List['models.Dataset']] = None
    dashboards: Optional[List['models.Dashboard']] = None
    projects: Optional[List['models.Project']] = None
    transactions: Optional[List['models.Transaction']] = None
    subscriptions: Optional[List['models.Subscription']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OrganizationKeys']] = None,
        exclude: Optional[Iterable['types.OrganizationKeys']] = None,
        required: Optional[Iterable['types.OrganizationKeys']] = None,
        optional: Optional[Iterable['types.OrganizationKeys']] = None,
        relations: Optional[Mapping['types.OrganizationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OrganizationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Organization_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Organization_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Organization_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Organization_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Organization_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Organization_relational_fields:
                        raise errors.UnknownRelationalFieldError('Organization', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Organization / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Organization',
            }
        )
        _created_partial_types.add(name)


class OrganizationMember(bases.BaseOrganizationMember):
    """Represents a OrganizationMember record"""

    id: _int
    organizationId: _int
    userId: _int
    role: Optional[_str] = None
    invitedById: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    organization: Optional['models.Organization'] = None
    user: Optional['models.User'] = None
    invitedBy: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        exclude: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        required: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        optional: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        relations: Optional[Mapping['types.OrganizationMemberRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OrganizationMemberKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _OrganizationMember_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _OrganizationMember_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _OrganizationMember_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _OrganizationMember_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _OrganizationMember_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _OrganizationMember_relational_fields:
                        raise errors.UnknownRelationalFieldError('OrganizationMember', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid OrganizationMember / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'OrganizationMember',
            }
        )
        _created_partial_types.add(name)


class Path(bases.BasePath):
    """Represents a Path record"""

    id: _int
    title: _str
    slug: _str
    description: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    modules: Optional[List['models.PathModule']] = None
    enrollments: Optional[List['models.Enrollment']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PathKeys']] = None,
        exclude: Optional[Iterable['types.PathKeys']] = None,
        required: Optional[Iterable['types.PathKeys']] = None,
        optional: Optional[Iterable['types.PathKeys']] = None,
        relations: Optional[Mapping['types.PathRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PathKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Path_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Path_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Path_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Path_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Path_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Path_relational_fields:
                        raise errors.UnknownRelationalFieldError('Path', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Path / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Path',
            }
        )
        _created_partial_types.add(name)


class Module(bases.BaseModule):
    """Represents a Module record"""

    id: _int
    title: _str
    slug: _str
    description: Optional[_str] = None
    fullDescription: Optional[_str] = None
    durationMinutes: Optional[_int] = None
    estimatedEffort: Optional[_str] = None
    totalLessons: Optional[_int] = None
    level: Optional[_str] = None
    instructorId: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    instructor: Optional['models.User'] = None
    lessons: Optional[List['models.Lesson']] = None
    certificates: Optional[List['models.Certificate']] = None
    enrollments: Optional[List['models.Enrollment']] = None
    pathLinks: Optional[List['models.PathModule']] = None
    skills: List[_str]
    tags: List[_str]
    priceCents: Optional[_int] = None
    featured: _bool
    lastUpdated: Optional[datetime.datetime] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('skills', 'tags', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ModuleKeys']] = None,
        exclude: Optional[Iterable['types.ModuleKeys']] = None,
        required: Optional[Iterable['types.ModuleKeys']] = None,
        optional: Optional[Iterable['types.ModuleKeys']] = None,
        relations: Optional[Mapping['types.ModuleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ModuleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Module_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Module_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Module_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Module_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Module_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Module_relational_fields:
                        raise errors.UnknownRelationalFieldError('Module', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Module / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Module',
            }
        )
        _created_partial_types.add(name)


class PathModule(bases.BasePathModule):
    """Represents a PathModule record"""

    id: _int
    pathId: _int
    moduleId: _int
    order: Optional[_int] = None
    path: Optional['models.Path'] = None
    module: Optional['models.Module'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PathModuleKeys']] = None,
        exclude: Optional[Iterable['types.PathModuleKeys']] = None,
        required: Optional[Iterable['types.PathModuleKeys']] = None,
        optional: Optional[Iterable['types.PathModuleKeys']] = None,
        relations: Optional[Mapping['types.PathModuleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PathModuleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PathModule_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PathModule_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PathModule_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PathModule_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PathModule_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PathModule_relational_fields:
                        raise errors.UnknownRelationalFieldError('PathModule', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PathModule / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PathModule',
            }
        )
        _created_partial_types.add(name)


class Lesson(bases.BaseLesson):
    """Represents a Lesson record"""

    id: _int
    moduleId: _int
    title: _str
    description: Optional[_str] = None
    durationMinutes: Optional[_int] = None
    type: _str
    videoUrl: Optional[_str] = None
    transcript: Optional[_str] = None
    attachments: Optional['fields.Json'] = None
    quizId: Optional[_int] = None
    requiredPassScore: Optional[_int] = None
    order: _int
    thumbnailUrl: Optional[_str] = None
    thumbnailBlurDataURL: Optional[_str] = None
    learningObjectives: List[_str]
    keyTakeaways: List[_str]
    instructorNotes: Optional[_str] = None
    estimatedCompletionTime: Optional[_int] = None
    difficulty: Optional[_str] = None
    tags: List[_str]
    relatedResources: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    module: Optional['models.Module'] = None
    progresses: Optional[List['models.LessonProgress']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('learningObjectives', 'keyTakeaways', 'tags', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LessonKeys']] = None,
        exclude: Optional[Iterable['types.LessonKeys']] = None,
        required: Optional[Iterable['types.LessonKeys']] = None,
        optional: Optional[Iterable['types.LessonKeys']] = None,
        relations: Optional[Mapping['types.LessonRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LessonKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Lesson_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Lesson_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Lesson_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Lesson_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Lesson_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Lesson_relational_fields:
                        raise errors.UnknownRelationalFieldError('Lesson', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Lesson / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Lesson',
            }
        )
        _created_partial_types.add(name)


class Enrollment(bases.BaseEnrollment):
    """Represents a Enrollment record"""

    id: _int
    userId: _int
    moduleId: Optional[_int] = None
    pathId: Optional[_int] = None
    startedAt: datetime.datetime
    completedAt: Optional[datetime.datetime] = None
    progress: _float
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    user: Optional['models.User'] = None
    module: Optional['models.Module'] = None
    path: Optional['models.Path'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EnrollmentKeys']] = None,
        exclude: Optional[Iterable['types.EnrollmentKeys']] = None,
        required: Optional[Iterable['types.EnrollmentKeys']] = None,
        optional: Optional[Iterable['types.EnrollmentKeys']] = None,
        relations: Optional[Mapping['types.EnrollmentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EnrollmentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Enrollment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Enrollment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Enrollment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Enrollment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Enrollment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Enrollment_relational_fields:
                        raise errors.UnknownRelationalFieldError('Enrollment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Enrollment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Enrollment',
            }
        )
        _created_partial_types.add(name)


class LessonProgress(bases.BaseLessonProgress):
    """Represents a LessonProgress record"""

    id: _int
    userId: _int
    lessonId: _int
    isCompleted: _bool
    completedAt: Optional[datetime.datetime] = None
    progress: _float
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    user: Optional['models.User'] = None
    lesson: Optional['models.Lesson'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LessonProgressKeys']] = None,
        exclude: Optional[Iterable['types.LessonProgressKeys']] = None,
        required: Optional[Iterable['types.LessonProgressKeys']] = None,
        optional: Optional[Iterable['types.LessonProgressKeys']] = None,
        relations: Optional[Mapping['types.LessonProgressRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LessonProgressKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LessonProgress_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LessonProgress_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LessonProgress_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LessonProgress_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LessonProgress_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LessonProgress_relational_fields:
                        raise errors.UnknownRelationalFieldError('LessonProgress', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LessonProgress / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LessonProgress',
            }
        )
        _created_partial_types.add(name)


class Certificate(bases.BaseCertificate):
    """Represents a Certificate record"""

    id: _int
    userId: _int
    moduleId: Optional[_int] = None
    fileUrl: _str
    issuedAt: datetime.datetime
    metadata: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    user: Optional['models.User'] = None
    module: Optional['models.Module'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CertificateKeys']] = None,
        exclude: Optional[Iterable['types.CertificateKeys']] = None,
        required: Optional[Iterable['types.CertificateKeys']] = None,
        optional: Optional[Iterable['types.CertificateKeys']] = None,
        relations: Optional[Mapping['types.CertificateRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CertificateKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Certificate_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Certificate_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Certificate_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Certificate_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Certificate_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Certificate_relational_fields:
                        raise errors.UnknownRelationalFieldError('Certificate', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Certificate / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Certificate',
            }
        )
        _created_partial_types.add(name)


class Project(bases.BaseProject):
    """Represents a Project record"""

    id: _int
    title: _str
    slug: _str
    description: Optional[_str] = None
    ownerId: Optional[_int] = None
    owner: Optional['models.User'] = None
    organizationId: Optional[_int] = None
    organization: Optional['models.Organization'] = None
    skills: List[_str]
    status: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    proposals: Optional[List['models.Proposal']] = None
    contracts: Optional[List['models.Contract']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('skills', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProjectKeys']] = None,
        exclude: Optional[Iterable['types.ProjectKeys']] = None,
        required: Optional[Iterable['types.ProjectKeys']] = None,
        optional: Optional[Iterable['types.ProjectKeys']] = None,
        relations: Optional[Mapping['types.ProjectRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProjectKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Project_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Project_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Project_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Project_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Project_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Project_relational_fields:
                        raise errors.UnknownRelationalFieldError('Project', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Project / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Project',
            }
        )
        _created_partial_types.add(name)


class Proposal(bases.BaseProposal):
    """Represents a Proposal record"""

    id: _int
    projectId: _int
    freelancerId: Optional[_int] = None
    message: Optional[_str] = None
    amountCents: Optional[_int] = None
    status: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    project: Optional['models.Project'] = None
    freelancer: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProposalKeys']] = None,
        exclude: Optional[Iterable['types.ProposalKeys']] = None,
        required: Optional[Iterable['types.ProposalKeys']] = None,
        optional: Optional[Iterable['types.ProposalKeys']] = None,
        relations: Optional[Mapping['types.ProposalRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProposalKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Proposal_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Proposal_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Proposal_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Proposal_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Proposal_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Proposal_relational_fields:
                        raise errors.UnknownRelationalFieldError('Proposal', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Proposal / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Proposal',
            }
        )
        _created_partial_types.add(name)


class Contract(bases.BaseContract):
    """Represents a Contract record"""

    id: _int
    projectId: _int
    freelancerId: Optional[_int] = None
    clientId: Optional[_int] = None
    terms: Optional[_str] = None
    startDate: Optional[datetime.datetime] = None
    endDate: Optional[datetime.datetime] = None
    status: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    project: Optional['models.Project'] = None
    freelancer: Optional['models.User'] = None
    client: Optional['models.User'] = None
    deliveries: Optional[List['models.Delivery']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ContractKeys']] = None,
        exclude: Optional[Iterable['types.ContractKeys']] = None,
        required: Optional[Iterable['types.ContractKeys']] = None,
        optional: Optional[Iterable['types.ContractKeys']] = None,
        relations: Optional[Mapping['types.ContractRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ContractKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Contract_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Contract_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Contract_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Contract_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Contract_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Contract_relational_fields:
                        raise errors.UnknownRelationalFieldError('Contract', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Contract / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Contract',
            }
        )
        _created_partial_types.add(name)


class Delivery(bases.BaseDelivery):
    """Represents a Delivery record"""

    id: _int
    contractId: _int
    description: Optional[_str] = None
    deliveredAt: datetime.datetime
    files: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    contract: Optional['models.Contract'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DeliveryKeys']] = None,
        exclude: Optional[Iterable['types.DeliveryKeys']] = None,
        required: Optional[Iterable['types.DeliveryKeys']] = None,
        optional: Optional[Iterable['types.DeliveryKeys']] = None,
        relations: Optional[Mapping['types.DeliveryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DeliveryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Delivery_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Delivery_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Delivery_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Delivery_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Delivery_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Delivery_relational_fields:
                        raise errors.UnknownRelationalFieldError('Delivery', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Delivery / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Delivery',
            }
        )
        _created_partial_types.add(name)


class UserSkill(bases.BaseUserSkill):
    """Represents a UserSkill record"""

    id: _int
    userId: _int
    name: _str
    createdAt: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserSkillKeys']] = None,
        exclude: Optional[Iterable['types.UserSkillKeys']] = None,
        required: Optional[Iterable['types.UserSkillKeys']] = None,
        optional: Optional[Iterable['types.UserSkillKeys']] = None,
        relations: Optional[Mapping['types.UserSkillRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserSkillKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserSkill_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserSkill_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserSkill_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserSkill_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserSkill_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserSkill_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserSkill', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserSkill / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserSkill',
            }
        )
        _created_partial_types.add(name)


class Dataset(bases.BaseDataset):
    """Represents a Dataset record"""

    id: _int
    name: _str
    slug: _str
    description: Optional[_str] = None
    userId: Optional[_int] = None
    organizationId: Optional[_int] = None
    sourceType: _str
    sourceUrl: Optional[_str] = None
    filePath: Optional[_str] = None
    schema_: Optional['fields.Json'] = None
    previewRows: Optional['fields.Json'] = None
    metadata: Optional['fields.Json'] = None
    processingStatus: 'enums.DatasetStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    ownerUser: Optional['models.User'] = None
    organization: Optional['models.Organization'] = None
    widgets: Optional[List['models.Widget']] = None
    dashboardLinks: Optional[List['models.DashboardDataset']] = None
    mlModels: Optional[List['models.MLModel']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DatasetKeys']] = None,
        exclude: Optional[Iterable['types.DatasetKeys']] = None,
        required: Optional[Iterable['types.DatasetKeys']] = None,
        optional: Optional[Iterable['types.DatasetKeys']] = None,
        relations: Optional[Mapping['types.DatasetRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DatasetKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Dataset_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Dataset_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Dataset_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Dataset_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Dataset_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Dataset_relational_fields:
                        raise errors.UnknownRelationalFieldError('Dataset', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Dataset / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Dataset',
            }
        )
        _created_partial_types.add(name)


class Dashboard(bases.BaseDashboard):
    """Represents a Dashboard record"""

    id: _int
    title: _str
    slug: _str
    description: Optional[_str] = None
    ownerId: Optional[_int] = None
    organizationId: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    ownerUser: Optional['models.User'] = None
    organization: Optional['models.Organization'] = None
    widgets: Optional[List['models.Widget']] = None
    datasetLinks: Optional[List['models.DashboardDataset']] = None
    insights: Optional[List['models.Insight']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DashboardKeys']] = None,
        exclude: Optional[Iterable['types.DashboardKeys']] = None,
        required: Optional[Iterable['types.DashboardKeys']] = None,
        optional: Optional[Iterable['types.DashboardKeys']] = None,
        relations: Optional[Mapping['types.DashboardRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DashboardKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Dashboard_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Dashboard_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Dashboard_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Dashboard_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Dashboard_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Dashboard_relational_fields:
                        raise errors.UnknownRelationalFieldError('Dashboard', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Dashboard / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Dashboard',
            }
        )
        _created_partial_types.add(name)


class DashboardDataset(bases.BaseDashboardDataset):
    """Represents a DashboardDataset record"""

    id: _int
    dashboardId: _int
    datasetId: _int
    addedAt: datetime.datetime
    dashboard: Optional['models.Dashboard'] = None
    dataset: Optional['models.Dataset'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DashboardDatasetKeys']] = None,
        exclude: Optional[Iterable['types.DashboardDatasetKeys']] = None,
        required: Optional[Iterable['types.DashboardDatasetKeys']] = None,
        optional: Optional[Iterable['types.DashboardDatasetKeys']] = None,
        relations: Optional[Mapping['types.DashboardDatasetRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DashboardDatasetKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _DashboardDataset_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _DashboardDataset_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _DashboardDataset_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _DashboardDataset_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _DashboardDataset_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _DashboardDataset_relational_fields:
                        raise errors.UnknownRelationalFieldError('DashboardDataset', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid DashboardDataset / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'DashboardDataset',
            }
        )
        _created_partial_types.add(name)


class Widget(bases.BaseWidget):
    """Represents a Widget record"""

    id: _int
    dashboardId: Optional[_int] = None
    datasetId: Optional[_int] = None
    type: 'enums.WidgetType'
    config: 'fields.Json'
    order: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    dashboard: Optional['models.Dashboard'] = None
    dataset: Optional['models.Dataset'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.WidgetKeys']] = None,
        exclude: Optional[Iterable['types.WidgetKeys']] = None,
        required: Optional[Iterable['types.WidgetKeys']] = None,
        optional: Optional[Iterable['types.WidgetKeys']] = None,
        relations: Optional[Mapping['types.WidgetRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.WidgetKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Widget_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Widget_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Widget_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Widget_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Widget_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Widget_relational_fields:
                        raise errors.UnknownRelationalFieldError('Widget', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Widget / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Widget',
            }
        )
        _created_partial_types.add(name)


class Insight(bases.BaseInsight):
    """Represents a Insight record"""

    id: _int
    dashboardId: _int
    userId: Optional[_int] = None
    content: _str
    metadata: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    dashboard: Optional['models.Dashboard'] = None
    author: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.InsightKeys']] = None,
        exclude: Optional[Iterable['types.InsightKeys']] = None,
        required: Optional[Iterable['types.InsightKeys']] = None,
        optional: Optional[Iterable['types.InsightKeys']] = None,
        relations: Optional[Mapping['types.InsightRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.InsightKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Insight_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Insight_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Insight_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Insight_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Insight_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Insight_relational_fields:
                        raise errors.UnknownRelationalFieldError('Insight', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Insight / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Insight',
            }
        )
        _created_partial_types.add(name)


class MLModel(bases.BaseMLModel):
    """Represents a MLModel record"""

    id: _int
    datasetId: _int
    creatorId: Optional[_int] = None
    name: _str
    type: _str
    modelPath: Optional[_str] = None
    metrics: Optional['fields.Json'] = None
    params: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    dataset: Optional['models.Dataset'] = None
    creator: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MLModelKeys']] = None,
        exclude: Optional[Iterable['types.MLModelKeys']] = None,
        required: Optional[Iterable['types.MLModelKeys']] = None,
        optional: Optional[Iterable['types.MLModelKeys']] = None,
        relations: Optional[Mapping['types.MLModelRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MLModelKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _MLModel_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _MLModel_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _MLModel_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _MLModel_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _MLModel_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _MLModel_relational_fields:
                        raise errors.UnknownRelationalFieldError('MLModel', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid MLModel / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'MLModel',
            }
        )
        _created_partial_types.add(name)


class Transaction(bases.BaseTransaction):
    """Represents a Transaction record"""

    id: _int
    userId: Optional[_int] = None
    organizationId: Optional[_int] = None
    amountCents: _int
    currency: _str
    type: _str
    status: 'enums.PaymentStatus'
    providerData: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    user: Optional['models.User'] = None
    organization: Optional['models.Organization'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TransactionKeys']] = None,
        exclude: Optional[Iterable['types.TransactionKeys']] = None,
        required: Optional[Iterable['types.TransactionKeys']] = None,
        optional: Optional[Iterable['types.TransactionKeys']] = None,
        relations: Optional[Mapping['types.TransactionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TransactionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Transaction_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Transaction_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Transaction_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Transaction_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Transaction_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Transaction_relational_fields:
                        raise errors.UnknownRelationalFieldError('Transaction', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Transaction / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Transaction',
            }
        )
        _created_partial_types.add(name)


class Subscription(bases.BaseSubscription):
    """Represents a Subscription record"""

    id: _int
    userId: Optional[_int] = None
    organizationId: Optional[_int] = None
    plan: 'enums.SubscriptionPlan'
    active: _bool
    startedAt: datetime.datetime
    endsAt: Optional[datetime.datetime] = None
    metadata: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    user: Optional['models.User'] = None
    organization: Optional['models.Organization'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SubscriptionKeys']] = None,
        exclude: Optional[Iterable['types.SubscriptionKeys']] = None,
        required: Optional[Iterable['types.SubscriptionKeys']] = None,
        optional: Optional[Iterable['types.SubscriptionKeys']] = None,
        relations: Optional[Mapping['types.SubscriptionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SubscriptionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Subscription_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Subscription_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Subscription_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Subscription_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Subscription_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Subscription_relational_fields:
                        raise errors.UnknownRelationalFieldError('Subscription', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Subscription / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Subscription',
            }
        )
        _created_partial_types.add(name)


class Notification(bases.BaseNotification):
    """Represents a Notification record"""

    id: _int
    userId: _int
    type: _str
    title: Optional[_str] = None
    body: _str
    data: Optional['fields.Json'] = None
    isRead: _bool
    emailSent: _bool
    emailSentAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.NotificationKeys']] = None,
        exclude: Optional[Iterable['types.NotificationKeys']] = None,
        required: Optional[Iterable['types.NotificationKeys']] = None,
        optional: Optional[Iterable['types.NotificationKeys']] = None,
        relations: Optional[Mapping['types.NotificationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.NotificationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Notification_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Notification_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Notification_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Notification_relational_fields:
                        raise errors.UnknownRelationalFieldError('Notification', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Notification / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Notification',
            }
        )
        _created_partial_types.add(name)


class AuthToken(bases.BaseAuthToken):
    """Represents a AuthToken record"""

    id: _int
    userId: _int
    token: _str
    type: _str
    expiresAt: datetime.datetime
    usedAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AuthTokenKeys']] = None,
        exclude: Optional[Iterable['types.AuthTokenKeys']] = None,
        required: Optional[Iterable['types.AuthTokenKeys']] = None,
        optional: Optional[Iterable['types.AuthTokenKeys']] = None,
        relations: Optional[Mapping['types.AuthTokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AuthTokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AuthToken_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AuthToken_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AuthToken_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AuthToken_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AuthToken_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AuthToken_relational_fields:
                        raise errors.UnknownRelationalFieldError('AuthToken', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AuthToken / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AuthToken',
            }
        )
        _created_partial_types.add(name)


class File(bases.BaseFile):
    """Represents a File record"""

    id: _int
    path: _str
    size: Optional[_int] = None
    mimeType: Optional[_str] = None
    uploadedBy: Optional[_int] = None
    createdAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    uploader: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FileKeys']] = None,
        exclude: Optional[Iterable['types.FileKeys']] = None,
        required: Optional[Iterable['types.FileKeys']] = None,
        optional: Optional[Iterable['types.FileKeys']] = None,
        relations: Optional[Mapping['types.FileRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FileKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _File_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _File_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _File_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _File_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _File_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _File_relational_fields:
                        raise errors.UnknownRelationalFieldError('File', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid File / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'File',
            }
        )
        _created_partial_types.add(name)


class AuditLog(bases.BaseAuditLog):
    """Represents a AuditLog record"""

    id: _int
    actorId: Optional[_int] = None
    action: _str
    model: Optional[_str] = None
    recordId: Optional[_str] = None
    changes: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    actor: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AuditLogKeys']] = None,
        exclude: Optional[Iterable['types.AuditLogKeys']] = None,
        required: Optional[Iterable['types.AuditLogKeys']] = None,
        optional: Optional[Iterable['types.AuditLogKeys']] = None,
        relations: Optional[Mapping['types.AuditLogRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AuditLogKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AuditLog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AuditLog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AuditLog_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AuditLog_relational_fields:
                        raise errors.UnknownRelationalFieldError('AuditLog', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AuditLog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AuditLog',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'primaryOrganization',
        'ownedOrganization',
        'memberships',
        'sentInvites',
        'enrollments',
        'lessonProgresses',
        'certificates',
        'instructedModules',
        'projects',
        'proposals',
        'contractsAsFreelancer',
        'contractsAsClient',
        'datasets',
        'dashboards',
        'insights',
        'mlModels',
        'transactions',
        'subscriptions',
        'notifications',
        'files',
        'authTokens',
        'auditLogs',
        'skillsDetails',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fullName', {
            'name': 'fullName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailVerified', {
            'name': 'emailVerified',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('passwordHash', {
            'name': 'passwordHash',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('provider', {
            'name': 'provider',
            'is_list': False,
            'optional': False,
            'type': 'enums.AuthProvider',
            'is_relational': False,
            'documentation': None,
        }),
        ('providerId', {
            'name': 'providerId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phoneNumber', {
            'name': 'phoneNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phoneVerified', {
            'name': 'phoneVerified',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('acceptedTerms', {
            'name': 'acceptedTerms',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('subscribeNewsletter', {
            'name': 'subscribeNewsletter',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastLoginAt', {
            'name': 'lastLoginAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('loginCount', {
            'name': 'loginCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('profilePictureUrl', {
            'name': 'profilePictureUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('bio', {
            'name': 'bio',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('country', {
            'name': 'country',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('city', {
            'name': 'city',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('socialLinks', {
            'name': 'socialLinks',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('primaryOrganizationId', {
            'name': 'primaryOrganizationId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('primaryOrganization', {
            'name': 'primaryOrganization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('ownedOrganization', {
            'name': 'ownedOrganization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('memberships', {
            'name': 'memberships',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('sentInvites', {
            'name': 'sentInvites',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('enrollments', {
            'name': 'enrollments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Enrollment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('lessonProgresses', {
            'name': 'lessonProgresses',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LessonProgress\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('certificates', {
            'name': 'certificates',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Certificate\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('instructedModules', {
            'name': 'instructedModules',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Module\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('projects', {
            'name': 'projects',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Project\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('proposals', {
            'name': 'proposals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Proposal\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('contractsAsFreelancer', {
            'name': 'contractsAsFreelancer',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Contract\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('contractsAsClient', {
            'name': 'contractsAsClient',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Contract\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('datasets', {
            'name': 'datasets',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Dataset\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('dashboards', {
            'name': 'dashboards',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Dashboard\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('insights', {
            'name': 'insights',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Insight\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('mlModels', {
            'name': 'mlModels',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.MLModel\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactions', {
            'name': 'transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('subscriptions', {
            'name': 'subscriptions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Subscription\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('notifications', {
            'name': 'notifications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Notification\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('files', {
            'name': 'files',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.File\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('authTokens', {
            'name': 'authTokens',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AuthToken\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('auditLogs', {
            'name': 'auditLogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AuditLog\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('skillsDetails', {
            'name': 'skillsDetails',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Organization_relational_fields: Set[str] = {
        'owner',
        'primaryUsers',
        'members',
        'datasets',
        'dashboards',
        'projects',
        'transactions',
        'subscriptions',
    }
_Organization_fields: Dict['types.OrganizationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('slug', {
            'name': 'slug',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('country', {
            'name': 'country',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('website', {
            'name': 'website',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('industry', {
            'name': 'industry',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('ownerId', {
            'name': 'ownerId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('owner', {
            'name': 'owner',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('primaryUsers', {
            'name': 'primaryUsers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.User\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('members', {
            'name': 'members',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('datasets', {
            'name': 'datasets',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Dataset\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('dashboards', {
            'name': 'dashboards',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Dashboard\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('projects', {
            'name': 'projects',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Project\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactions', {
            'name': 'transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('subscriptions', {
            'name': 'subscriptions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Subscription\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_OrganizationMember_relational_fields: Set[str] = {
        'organization',
        'user',
        'invitedBy',
    }
_OrganizationMember_fields: Dict['types.OrganizationMemberKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('invitedById', {
            'name': 'invitedById',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('invitedBy', {
            'name': 'invitedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Path_relational_fields: Set[str] = {
        'modules',
        'enrollments',
    }
_Path_fields: Dict['types.PathKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('slug', {
            'name': 'slug',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('modules', {
            'name': 'modules',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PathModule\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('enrollments', {
            'name': 'enrollments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Enrollment\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Module_relational_fields: Set[str] = {
        'instructor',
        'lessons',
        'certificates',
        'enrollments',
        'pathLinks',
    }
_Module_fields: Dict['types.ModuleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('slug', {
            'name': 'slug',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fullDescription', {
            'name': 'fullDescription',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('durationMinutes', {
            'name': 'durationMinutes',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('estimatedEffort', {
            'name': 'estimatedEffort',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalLessons', {
            'name': 'totalLessons',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('level', {
            'name': 'level',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('instructorId', {
            'name': 'instructorId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('instructor', {
            'name': 'instructor',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('lessons', {
            'name': 'lessons',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Lesson\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('certificates', {
            'name': 'certificates',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Certificate\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('enrollments', {
            'name': 'enrollments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Enrollment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pathLinks', {
            'name': 'pathLinks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PathModule\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('tags', {
            'name': 'tags',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('priceCents', {
            'name': 'priceCents',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('featured', {
            'name': 'featured',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastUpdated', {
            'name': 'lastUpdated',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_PathModule_relational_fields: Set[str] = {
        'path',
        'module',
    }
_PathModule_fields: Dict['types.PathModuleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pathId', {
            'name': 'pathId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('moduleId', {
            'name': 'moduleId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('order', {
            'name': 'order',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('path', {
            'name': 'path',
            'is_list': False,
            'optional': True,
            'type': 'models.Path',
            'is_relational': True,
            'documentation': None,
        }),
        ('module', {
            'name': 'module',
            'is_list': False,
            'optional': True,
            'type': 'models.Module',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Lesson_relational_fields: Set[str] = {
        'module',
        'progresses',
    }
_Lesson_fields: Dict['types.LessonKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('moduleId', {
            'name': 'moduleId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('durationMinutes', {
            'name': 'durationMinutes',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('videoUrl', {
            'name': 'videoUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('transcript', {
            'name': 'transcript',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('attachments', {
            'name': 'attachments',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('quizId', {
            'name': 'quizId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('requiredPassScore', {
            'name': 'requiredPassScore',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('order', {
            'name': 'order',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('thumbnailUrl', {
            'name': 'thumbnailUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('thumbnailBlurDataURL', {
            'name': 'thumbnailBlurDataURL',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('learningObjectives', {
            'name': 'learningObjectives',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('keyTakeaways', {
            'name': 'keyTakeaways',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('instructorNotes', {
            'name': 'instructorNotes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('estimatedCompletionTime', {
            'name': 'estimatedCompletionTime',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('difficulty', {
            'name': 'difficulty',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tags', {
            'name': 'tags',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('relatedResources', {
            'name': 'relatedResources',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('module', {
            'name': 'module',
            'is_list': False,
            'optional': True,
            'type': 'models.Module',
            'is_relational': True,
            'documentation': None,
        }),
        ('progresses', {
            'name': 'progresses',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LessonProgress\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Enrollment_relational_fields: Set[str] = {
        'user',
        'module',
        'path',
    }
_Enrollment_fields: Dict['types.EnrollmentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('moduleId', {
            'name': 'moduleId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pathId', {
            'name': 'pathId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('startedAt', {
            'name': 'startedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completedAt', {
            'name': 'completedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('progress', {
            'name': 'progress',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('module', {
            'name': 'module',
            'is_list': False,
            'optional': True,
            'type': 'models.Module',
            'is_relational': True,
            'documentation': None,
        }),
        ('path', {
            'name': 'path',
            'is_list': False,
            'optional': True,
            'type': 'models.Path',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LessonProgress_relational_fields: Set[str] = {
        'user',
        'lesson',
    }
_LessonProgress_fields: Dict['types.LessonProgressKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('lessonId', {
            'name': 'lessonId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isCompleted', {
            'name': 'isCompleted',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('completedAt', {
            'name': 'completedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('progress', {
            'name': 'progress',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('lesson', {
            'name': 'lesson',
            'is_list': False,
            'optional': True,
            'type': 'models.Lesson',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Certificate_relational_fields: Set[str] = {
        'user',
        'module',
    }
_Certificate_fields: Dict['types.CertificateKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('moduleId', {
            'name': 'moduleId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fileUrl', {
            'name': 'fileUrl',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('issuedAt', {
            'name': 'issuedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('module', {
            'name': 'module',
            'is_list': False,
            'optional': True,
            'type': 'models.Module',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Project_relational_fields: Set[str] = {
        'owner',
        'organization',
        'proposals',
        'contracts',
    }
_Project_fields: Dict['types.ProjectKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('slug', {
            'name': 'slug',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ownerId', {
            'name': 'ownerId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('owner', {
            'name': 'owner',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('proposals', {
            'name': 'proposals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Proposal\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('contracts', {
            'name': 'contracts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Contract\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Proposal_relational_fields: Set[str] = {
        'project',
        'freelancer',
    }
_Proposal_fields: Dict['types.ProposalKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('freelancerId', {
            'name': 'freelancerId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('amountCents', {
            'name': 'amountCents',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('freelancer', {
            'name': 'freelancer',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Contract_relational_fields: Set[str] = {
        'project',
        'freelancer',
        'client',
        'deliveries',
    }
_Contract_fields: Dict['types.ContractKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('freelancerId', {
            'name': 'freelancerId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientId', {
            'name': 'clientId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('terms', {
            'name': 'terms',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('startDate', {
            'name': 'startDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endDate', {
            'name': 'endDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('freelancer', {
            'name': 'freelancer',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('client', {
            'name': 'client',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('deliveries', {
            'name': 'deliveries',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Delivery\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Delivery_relational_fields: Set[str] = {
        'contract',
    }
_Delivery_fields: Dict['types.DeliveryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('contractId', {
            'name': 'contractId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('deliveredAt', {
            'name': 'deliveredAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('files', {
            'name': 'files',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('contract', {
            'name': 'contract',
            'is_list': False,
            'optional': True,
            'type': 'models.Contract',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserSkill_relational_fields: Set[str] = {
        'user',
    }
_UserSkill_fields: Dict['types.UserSkillKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Dataset_relational_fields: Set[str] = {
        'ownerUser',
        'organization',
        'widgets',
        'dashboardLinks',
        'mlModels',
    }
_Dataset_fields: Dict['types.DatasetKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('slug', {
            'name': 'slug',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sourceType', {
            'name': 'sourceType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sourceUrl', {
            'name': 'sourceUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('filePath', {
            'name': 'filePath',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('schema_', {
            'name': 'schema_',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('previewRows', {
            'name': 'previewRows',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('processingStatus', {
            'name': 'processingStatus',
            'is_list': False,
            'optional': False,
            'type': 'enums.DatasetStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('ownerUser', {
            'name': 'ownerUser',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('widgets', {
            'name': 'widgets',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Widget\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('dashboardLinks', {
            'name': 'dashboardLinks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DashboardDataset\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('mlModels', {
            'name': 'mlModels',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.MLModel\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Dashboard_relational_fields: Set[str] = {
        'ownerUser',
        'organization',
        'widgets',
        'datasetLinks',
        'insights',
    }
_Dashboard_fields: Dict['types.DashboardKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('slug', {
            'name': 'slug',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ownerId', {
            'name': 'ownerId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('ownerUser', {
            'name': 'ownerUser',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('widgets', {
            'name': 'widgets',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Widget\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('datasetLinks', {
            'name': 'datasetLinks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DashboardDataset\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('insights', {
            'name': 'insights',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Insight\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_DashboardDataset_relational_fields: Set[str] = {
        'dashboard',
        'dataset',
    }
_DashboardDataset_fields: Dict['types.DashboardDatasetKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('dashboardId', {
            'name': 'dashboardId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('datasetId', {
            'name': 'datasetId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('addedAt', {
            'name': 'addedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('dashboard', {
            'name': 'dashboard',
            'is_list': False,
            'optional': True,
            'type': 'models.Dashboard',
            'is_relational': True,
            'documentation': None,
        }),
        ('dataset', {
            'name': 'dataset',
            'is_list': False,
            'optional': True,
            'type': 'models.Dataset',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Widget_relational_fields: Set[str] = {
        'dashboard',
        'dataset',
    }
_Widget_fields: Dict['types.WidgetKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('dashboardId', {
            'name': 'dashboardId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('datasetId', {
            'name': 'datasetId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.WidgetType',
            'is_relational': False,
            'documentation': None,
        }),
        ('config', {
            'name': 'config',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('order', {
            'name': 'order',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('dashboard', {
            'name': 'dashboard',
            'is_list': False,
            'optional': True,
            'type': 'models.Dashboard',
            'is_relational': True,
            'documentation': None,
        }),
        ('dataset', {
            'name': 'dataset',
            'is_list': False,
            'optional': True,
            'type': 'models.Dataset',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Insight_relational_fields: Set[str] = {
        'dashboard',
        'author',
    }
_Insight_fields: Dict['types.InsightKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('dashboardId', {
            'name': 'dashboardId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('dashboard', {
            'name': 'dashboard',
            'is_list': False,
            'optional': True,
            'type': 'models.Dashboard',
            'is_relational': True,
            'documentation': None,
        }),
        ('author', {
            'name': 'author',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_MLModel_relational_fields: Set[str] = {
        'dataset',
        'creator',
    }
_MLModel_fields: Dict['types.MLModelKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('datasetId', {
            'name': 'datasetId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('creatorId', {
            'name': 'creatorId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('modelPath', {
            'name': 'modelPath',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metrics', {
            'name': 'metrics',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('params', {
            'name': 'params',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('dataset', {
            'name': 'dataset',
            'is_list': False,
            'optional': True,
            'type': 'models.Dataset',
            'is_relational': True,
            'documentation': None,
        }),
        ('creator', {
            'name': 'creator',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Transaction_relational_fields: Set[str] = {
        'user',
        'organization',
    }
_Transaction_fields: Dict['types.TransactionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('amountCents', {
            'name': 'amountCents',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('currency', {
            'name': 'currency',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.PaymentStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('providerData', {
            'name': 'providerData',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Subscription_relational_fields: Set[str] = {
        'user',
        'organization',
    }
_Subscription_fields: Dict['types.SubscriptionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('plan', {
            'name': 'plan',
            'is_list': False,
            'optional': False,
            'type': 'enums.SubscriptionPlan',
            'is_relational': False,
            'documentation': None,
        }),
        ('active', {
            'name': 'active',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('startedAt', {
            'name': 'startedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endsAt', {
            'name': 'endsAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Notification_relational_fields: Set[str] = {
        'user',
    }
_Notification_fields: Dict['types.NotificationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('body', {
            'name': 'body',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('data', {
            'name': 'data',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('isRead', {
            'name': 'isRead',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailSent', {
            'name': 'emailSent',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailSentAt', {
            'name': 'emailSentAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AuthToken_relational_fields: Set[str] = {
        'user',
    }
_AuthToken_fields: Dict['types.AuthTokenKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('token', {
            'name': 'token',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('usedAt', {
            'name': 'usedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_File_relational_fields: Set[str] = {
        'uploader',
    }
_File_fields: Dict['types.FileKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('path', {
            'name': 'path',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('size', {
            'name': 'size',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('mimeType', {
            'name': 'mimeType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('uploadedBy', {
            'name': 'uploadedBy',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('uploader', {
            'name': 'uploader',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AuditLog_relational_fields: Set[str] = {
        'actor',
    }
_AuditLog_fields: Dict['types.AuditLogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('actorId', {
            'name': 'actorId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('action', {
            'name': 'action',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('recordId', {
            'name': 'recordId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('changes', {
            'name': 'changes',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('actor', {
            'name': 'actor',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Organization)
model_rebuild(OrganizationMember)
model_rebuild(Path)
model_rebuild(Module)
model_rebuild(PathModule)
model_rebuild(Lesson)
model_rebuild(Enrollment)
model_rebuild(LessonProgress)
model_rebuild(Certificate)
model_rebuild(Project)
model_rebuild(Proposal)
model_rebuild(Contract)
model_rebuild(Delivery)
model_rebuild(UserSkill)
model_rebuild(Dataset)
model_rebuild(Dashboard)
model_rebuild(DashboardDataset)
model_rebuild(Widget)
model_rebuild(Insight)
model_rebuild(MLModel)
model_rebuild(Transaction)
model_rebuild(Subscription)
model_rebuild(Notification)
model_rebuild(AuthToken)
model_rebuild(File)
model_rebuild(AuditLog)
